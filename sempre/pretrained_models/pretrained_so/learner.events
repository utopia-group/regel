iter=0	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=0.143	oracle=1	partCorrect=0.143	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=66	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=0	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{<num>,repeat(<num>,4)},<.>)")	predFormula="sep(?{<num>,repeat(<num>,4)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=39	parseTime=35270	maxCellSize=33069	fallOffBeam=1	totalDerivs=2306519	numOfFeaturizedDerivs=2306519
iter=0	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "sep(?{<num>,concat(<num>,and(<,>,repeat(<num>,3)))},<.>)")	predFormula="sep(?{<num>,concat(<num>,and(<,>,repeat(<num>,3)))},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=32	parseTime=2181	maxCellSize=1681	fallOffBeam=1	totalDerivs=168080	numOfFeaturizedDerivs=168080
iter=0	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(?{or(repeat(<num>,1),repeat(<num>,2))},and(?{<.>},?{or(repeat(<num>,1),repeat(<num>,2))}))")	predFormula="concat(?{or(repeat(<num>,1),repeat(<num>,2))},and(?{<.>},?{or(repeat(<num>,1),repeat(<num>,2))}))"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=38	correctMaxBeamPosition=38	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=152	maxCellSize=519	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=0	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),repeatatleast(or(<0>,<5>),1)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),repeatatleast(or(<0>,<5>),1)},<.>)"	correct=0.031	oracle=1	partCorrect=0.031	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=0	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name "and(?{<let>,<num>},?{<space>})")	predFormula="and(?{<let>,<num>},?{<space>})"	correct=0.033	oracle=1	partCorrect=0.033	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=18	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=0	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "concat(?{repeatrange(<num>,1,18)},and(?{<num>},concat(and(?{<num>},?{<num>}),?{<num>})))")	predFormula="concat(?{repeatrange(<num>,1,18)},and(?{<num>},concat(and(?{<num>},?{<num>}),?{<num>})))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=30	parseTime=2183	maxCellSize=2957	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=0	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name "and(?{repeatatleast(<alphanum>,1),<space>},?{<let>,<_>})")	predFormula="and(?{repeatatleast(<alphanum>,1),<space>},?{<let>,<_>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=144	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=0	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.083	oracle=1	partCorrect=0.083	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=0	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name "not(?{<num>})")	predFormula="not(?{<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=10	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=0	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->,<any>})	predFormula=?{<num>,<->,<any>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=0	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "and(?{<alphanum>,<space>},?{<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<any>,<%>,<&>,<^>})")	predFormula="and(?{<alphanum>,<space>},?{<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<any>,<%>,<&>,<^>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14187	maxCellSize=1461	fallOffBeam=1	totalDerivs=419811	numOfFeaturizedDerivs=419811
iter=0	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "and(?{<let>,or(<let>,<num>),<space>},?{<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))})")	predFormula="and(?{<let>,or(<let>,<num>),<space>},?{<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=20	parseTime=168	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=0	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(?{<space>})")	predFormula="not(?{<space>})"	correct=0.200	oracle=1	partCorrect=0.200	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=4	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=0	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "and(?{endwith(<%>)},<num>)")	predFormula="and(?{endwith(<%>)},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=25	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=0	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<let>,6),<let>,<num>}")	predFormula="?{repeat(<let>,6),<let>,<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=22	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=0	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{startwith(repeat(<hex>,8)),<let>},concat(?{<_>},?{<num>,<let>}))")	predFormula="concat(?{startwith(repeat(<hex>,8)),<let>},concat(?{<_>},?{<num>,<let>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=2014	maxCellSize=2950	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=0	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "concat(<num>,?{<num>,not(<num>)})")	predFormula="concat(<num>,?{<num>,not(<num>)})"	correct=0.037	oracle=1	partCorrect=0.037	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=0	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "and(?{<let>,<any>,<uppera>,<upperb>,<upperc>},?{repeat(<let>,3),<num>})")	predFormula="and(?{<let>,<any>,<uppera>,<upperb>,<upperc>},?{repeat(<let>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1538	maxCellSize=4755	fallOffBeam=1	totalDerivs=148555	numOfFeaturizedDerivs=148555
iter=0	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>},<alphanum>)")	predFormula="sep(?{<any>},<alphanum>)"	correct=0.048	oracle=1	partCorrect=0.048	partOracle=1	correctIndexAfterParse=12	correctMaxBeamPosition=12	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=0	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeatatleast(<num>,1)}")	predFormula="?{repeatatleast(<num>,1)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=6	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=0	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(sep(and(?{<let>},<space>),<num>),<space>)")	predFormula="sep(sep(and(?{<let>},<space>),<num>),<space>)"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=127	correctMaxBeamPosition=127	correctMaxUnsortedBeamPosition=12	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=284	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=0	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(concat(<.>,?{<.>}))")	predFormula="not(concat(<.>,?{<.>}))"	correct=0.030	oracle=1	partCorrect=0.030	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=43	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=0	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<spec>,<let>})	predFormula=?{<num>,<spec>,<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=24	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=0	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},<let>)")	predFormula="sep(?{<num>},<let>)"	correct=0.042	oracle=1	partCorrect=0.042	partOracle=1	correctIndexAfterParse=18	correctMaxBeamPosition=18	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=24	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=0	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "and(?{repeatatleast(<num>,1),<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))},?{<space>})")	predFormula="and(?{repeatatleast(<num>,1),<let>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))},?{<space>})"	correct=0.008	oracle=1	partCorrect=0.008	partOracle=1	correctIndexAfterParse=80	correctMaxBeamPosition=80	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=25	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=0	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "concat(concat(not(<0>),?{repeat(<let>,3),repeat(<let>,20)}),?{<num>})")	predFormula="concat(concat(not(<0>),?{repeat(<let>,3),repeat(<let>,20)}),?{<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=1021	maxCellSize=2927	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=0	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name ?{<any>,<let>,<uppera>,<upperb>})	predFormula=?{<any>,<let>,<uppera>,<upperb>}	correct=0.053	oracle=1	partCorrect=0.053	partOracle=1	correctIndexAfterParse=16	correctMaxBeamPosition=16	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=87	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=0	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "and(?{<num>,repeatatleast(<num>,10)},?{<num>,not(<$>)})")	predFormula="and(?{<num>,repeatatleast(<num>,10)},?{<num>,not(<$>)})"	correct=0.006	oracle=1	partCorrect=0.006	partOracle=1	correctIndexAfterParse=139	correctMaxBeamPosition=139	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=132	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=0	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "concat(not(and(<let>,concat(not(<+>),<spec>))),?{startwith(<+>)})")	predFormula="concat(not(and(<let>,concat(not(<+>),<spec>))),?{startwith(<+>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=5048	maxCellSize=12682	fallOffBeam=1	totalDerivs=383742	numOfFeaturizedDerivs=383742
iter=0	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeat(<let>,3),<num>,repeat(<let>,2),<space>}")	predFormula="?{repeat(<let>,6),repeat(<let>,3),<num>,repeat(<let>,2),<space>}"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=88	correctMaxBeamPosition=88	correctMaxUnsortedBeamPosition=251	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2914	maxCellSize=1287	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=0	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "and(?{startwith(concat(<upperc>,<0>))},endwith(repeat(<num>,4)))")	predFormula="and(?{startwith(concat(<upperc>,<0>))},endwith(repeat(<num>,4)))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=31	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=0	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{repeatatleast(<num>,1),and(<,>,<->)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),and(<,>,<->)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=280	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=0	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name "and(?{<any>,<alphanum>,<let>},?{<->,not(<->)})")	predFormula="and(?{<any>,<alphanum>,<let>},?{<->,not(<->)})"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=182	correctMaxBeamPosition=182	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=144	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=0	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(and(?{<num>},startwith(and(concat(<0>,<7>),startwith(concat(<4>,concat(<4>,<7>)))))),<num>)")	predFormula="sep(and(?{<num>},startwith(and(concat(<0>,<7>),startwith(concat(<4>,concat(<4>,<7>)))))),<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10763	maxCellSize=4233	fallOffBeam=1	totalDerivs=517890	numOfFeaturizedDerivs=517890
iter=0	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "and(?{<let>,<alphanum>},and(?{<.>,concat(<%>,concat(<d>,concat(<4>,<%>)))},?{concat(<%>,concat(<t>,concat(<7>,<%>))),<%>}))")	predFormula="and(?{<let>,<alphanum>},and(?{<.>,concat(<%>,concat(<d>,concat(<4>,<%>)))},?{concat(<%>,concat(<t>,concat(<7>,<%>))),<%>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=47	parseTime=2481	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=0	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0.091	oracle=1	partCorrect=0.091	partOracle=1	correctIndexAfterParse=6	correctMaxBeamPosition=6	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=3	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=0	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "and(?{<any>,repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(<uppers>,concat(<o>,<->)),concat(<s>,concat(<o>,<->)),concat(<s>,concat(<uppero>,<->))},concat(?{concat(<uppers>,concat(<uppero>,<->))},?{repeat(<num>,6)}))")	predFormula="and(?{<any>,repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(<uppers>,concat(<o>,<->)),concat(<s>,concat(<o>,<->)),concat(<s>,concat(<uppero>,<->))},concat(?{concat(<uppers>,concat(<uppero>,<->))},?{repeat(<num>,6)}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=43	parseTime=4593	maxCellSize=10987	fallOffBeam=1	totalDerivs=357517	numOfFeaturizedDerivs=357517
iter=0	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "not(and(?{endwith(<spec>)},repeat(<any>,3)))")	predFormula="not(and(?{endwith(<spec>)},repeat(<any>,3)))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=32	parseTime=307	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=0	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(and(?{<%>},?{<%>,repeat(<let>,3),<any>}))")	predFormula="not(and(?{<%>},?{<%>,repeat(<let>,3),<any>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=2046	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=0	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0.077	oracle=1	partCorrect=0.077	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=16	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=0	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name "concat(concat(<spec>,?{<let>,<num>}),?{<let>})")	predFormula="concat(concat(<spec>,?{<let>,<num>}),?{<let>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=86	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=0	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "and(?{repeat(<let>,3),<any>,<let>,<uppera>,<upperb>,<upperc>,<upperz>},?{repeatrange(<let>,1,2)})")	predFormula="and(?{repeat(<let>,3),<any>,<let>,<uppera>,<upperb>,<upperc>,<upperz>},?{repeatrange(<let>,1,2)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=6537	maxCellSize=9718	fallOffBeam=1	totalDerivs=390374	numOfFeaturizedDerivs=390374
iter=0	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "concat(<num>,?{<num>})")	predFormula="concat(<num>,?{<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8200	maxCellSize=1732	fallOffBeam=1	totalDerivs=291156	numOfFeaturizedDerivs=291156
iter=0	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=9	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=0	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0.200	oracle=1	partCorrect=0.200	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=0	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "concat(?{<%>},?{repeat(<let>,2)})")	predFormula="concat(?{<%>},?{repeat(<let>,2)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=7	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=0	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "not(and(?{startwith(<space>),not(<space>)},not(?{endwith(<space>)})))")	predFormula="not(and(?{startwith(<space>),not(<space>)},not(?{endwith(<space>)})))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=22	parseTime=175	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=0	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "and(?{<any>,repeat(<num>,4)},?{<space>})")	predFormula="and(?{<any>,repeat(<num>,4)},?{<space>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=26	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=0	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "concat(<any>,?{<any>,star(<let>),<num>,<_>})")	predFormula="concat(<any>,?{<any>,star(<let>),<num>,<_>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=46	parseTime=5264	maxCellSize=1733	fallOffBeam=1	totalDerivs=236307	numOfFeaturizedDerivs=236307
iter=0	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{<:>,repeat(<num>,3),<any>}")	predFormula="?{<:>,repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=103	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=0	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},and(?{<upperx>},concat(?{<^>},?{repeatatleast(<num>,1)})))")	predFormula="concat(?{<num>},and(?{<upperx>},concat(?{<^>},?{repeatatleast(<num>,1)})))"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=61	correctMaxBeamPosition=61	correctMaxUnsortedBeamPosition=1221	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=235	maxCellSize=1261	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=0	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),repeatatleast(<num>,1),startwith(<9>)}")	predFormula="?{repeat(<num>,10),repeatatleast(<num>,1),startwith(<9>)}"	correct=0.034	oracle=1	partCorrect=0.034	partOracle=1	correctIndexAfterParse=12	correctMaxBeamPosition=12	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=59	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=0	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>,<any>})	predFormula=?{<let>,<any>}	correct=0.333	oracle=1	partCorrect=0.333	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=0	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,4)},<.>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,4)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=0	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,2)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,2)}"	correct=0.011	oracle=1	partCorrect=0.011	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=52	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=0	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,<,>},<.>)")	predFormula="sep(?{<num>,<,>},<.>)"	correct=0.059	oracle=1	partCorrect=0.059	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=231	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=0	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "and(?{<let>,<num>},?{<space>,not(repeat(<let>,3))})")	predFormula="and(?{<let>,<num>},?{<space>,not(repeat(<let>,3))})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=207	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=0	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "concat(?{<any>,not(<let>),<<>},?{notcc(<space>)})")	predFormula="concat(?{<any>,not(<let>),<<>},?{notcc(<space>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=33	parseTime=258	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=0	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<any>)")	predFormula="sep(?{<num>},<any>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=0	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name ?{<uppera>,<upperb>,<upperc>})	predFormula=?{<uppera>,<upperb>,<upperc>}	correct=0.083	oracle=1	partCorrect=0.083	partOracle=1	correctIndexAfterParse=6	correctMaxBeamPosition=6	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=15	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=0	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(sep(?{<num>},<num>),<any>)")	predFormula="sep(sep(?{<num>},<num>),<any>)"	correct=0.005	oracle=1	partCorrect=0.005	partOracle=1	correctIndexAfterParse=139	correctMaxBeamPosition=139	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=357	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=0	group=train	correct=0.042	oracle=0.435	partCorrect=0.042	partOracle=0.435	correctIndexAfterParse=35.259	correctMaxBeamPosition=35.259	correctMaxUnsortedBeamPosition=74.444	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.435	numPartialCorrect=0	numIncorrect=107.887	numTokens=27.694	parseTime=1776.710	maxCellSize=1638.194	fallOffBeam=0.452	totalDerivs=102337.839	numOfFeaturizedDerivs=102337.839
iter=1	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=8	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=1	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "concat(repeat(<num>,4),sep(?{or(<num>,<,>),concat(repeat(<num>,5),repeat(<num>,2))},<.>))")	predFormula="concat(repeat(<num>,4),sep(?{or(<num>,<,>),concat(repeat(<num>,5),repeat(<num>,2))},<.>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=39	parseTime=33273	maxCellSize=33420	fallOffBeam=1	totalDerivs=2326573	numOfFeaturizedDerivs=2326573
iter=1	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,concat(<,>,repeat(<num>,3))})")	predFormula="concat(<num>,?{<,>,concat(<,>,repeat(<num>,3))})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=32	parseTime=2212	maxCellSize=1679	fallOffBeam=1	totalDerivs=168766	numOfFeaturizedDerivs=168766
iter=1	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=519	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=1	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=1	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name "?{or(<num>,<space>)}")	predFormula="?{or(<num>,<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=19	correctMaxBeamPosition=19	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=18	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=1	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "concat(repeatrange(<num>,1,18),sep(?{<num>},<.>))")	predFormula="concat(repeatrange(<num>,1,18),sep(?{<num>},<.>))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=124	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2107	maxCellSize=2904	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=1	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<space>,<_>})	predFormula=?{<space>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=143	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=1	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=1	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=10	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=1	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<->,<any>})	predFormula=?{<->,<any>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=8	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=1	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14532	maxCellSize=1537	fallOffBeam=1	totalDerivs=423511	numOfFeaturizedDerivs=423511
iter=1	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{<space>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predFormula="?{<space>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=33	correctMaxBeamPosition=33	correctMaxUnsortedBeamPosition=345	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=172	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=1	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=1	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>)}")	predFormula="?{endwith(<%>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=20	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=1	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<let>,6),<let>}")	predFormula="?{repeat(<let>,6),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=17	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=1	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(startwith(repeat(<hex>,8)),?{concat(<_>,<let>)})")	predFormula="concat(startwith(repeat(<hex>,8)),?{concat(<_>,<let>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1671	maxCellSize=2949	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=1	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=1	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(repeatatleast(or(<uppera>,or(<upperb>,<upperc>)),1),?{repeat(<let>,3),<num>})")	predFormula="concat(repeatatleast(or(<uppera>,or(<upperb>,<upperc>)),1),?{repeat(<let>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1530	maxCellSize=4774	fallOffBeam=1	totalDerivs=148717	numOfFeaturizedDerivs=148717
iter=1	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>},<,>)")	predFormula="sep(?{<any>},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=1	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,16)}")	predFormula="?{repeat(<num>,16)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=1	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(sep(?{<let>},<space>),<space>)")	predFormula="sep(sep(?{<let>},<space>),<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=13	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=278	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=1	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=41	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=1	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=26	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=1	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=1	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=24	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=1	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<num>,3),concat(<0>,repeat(<let>,20))}")	predFormula="?{repeat(<num>,3),concat(<0>,repeat(<let>,20))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=992	maxCellSize=2810	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=1	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=88	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=1	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=131	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=1	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(not(contain(?{concat(<+>,<let>)})),startwith(<+>))")	predFormula="sep(not(contain(?{concat(<+>,<let>)})),startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4922	maxCellSize=12599	fallOffBeam=1	totalDerivs=383914	numOfFeaturizedDerivs=383914
iter=1	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeat(<let>,3),repeat(<let>,2),<space>}")	predFormula="?{repeat(<let>,6),repeat(<let>,3),repeat(<let>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=6	correctMaxBeamPosition=6	correctMaxUnsortedBeamPosition=593	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=3266	maxCellSize=1262	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=1	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(concat(<upperc>,<0>)),endwith(repeat(<num>,4))}")	predFormula="?{startwith(concat(<upperc>,<0>)),endwith(repeat(<num>,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=26	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=1	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "?{repeat(<num>,2),<,>,<->}")	predFormula="?{repeat(<num>,2),<,>,<->}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=223	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=1	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name "not(contain(?{<->}))")	predFormula="not(contain(?{<->}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=24	correctMaxBeamPosition=24	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=115	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=1	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)")	predFormula="sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10695	maxCellSize=4304	fallOffBeam=1	totalDerivs=519886	numOfFeaturizedDerivs=519886
iter=1	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=252	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2668	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=1	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{or(repeat(<num>,7),repeat(<num>,10))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=5	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=1	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "?{repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),repeat(<num>,6))}")	predFormula="?{repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),repeat(<num>,6))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=43	parseTime=4641	maxCellSize=11035	fallOffBeam=1	totalDerivs=357421	numOfFeaturizedDerivs=357421
iter=1	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "not(contain(?{repeat(<any>,25)}))")	predFormula="not(contain(?{repeat(<any>,25)}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=126	correctMaxBeamPosition=126	correctMaxUnsortedBeamPosition=68	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=308	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=1	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(contain(?{and(<%>,<%>),repeat(<let>,3),<%>,<any>}))")	predFormula="not(contain(?{and(<%>,<%>),repeat(<let>,3),<%>,<any>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1932	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=1	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=1	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name "?{concat(concat(<let>,<let>),<let>)}")	predFormula="?{concat(concat(<let>,<let>),<let>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=80	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=1	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(repeat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),3),?{repeatrange(<let>,1,2)})")	predFormula="concat(repeat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),3),?{repeatrange(<let>,1,2)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=24	correctMaxBeamPosition=24	correctMaxUnsortedBeamPosition=873	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6440	maxCellSize=9234	fallOffBeam=1	totalDerivs=390122	numOfFeaturizedDerivs=390122
iter=1	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{concat(or(<1>,<2>),<num>),repeat(<num>,2),startwith(startwith(<0>))}")	predFormula="?{concat(or(<1>,<2>),<num>),repeat(<num>,2),startwith(startwith(<0>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8189	maxCellSize=1823	fallOffBeam=1	totalDerivs=291538	numOfFeaturizedDerivs=291538
iter=1	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=8	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=1	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=1	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{concat(<%>,repeat(<let>,2))}")	predFormula="?{concat(<%>,repeat(<let>,2))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=6	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=1	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{startwith(not(contain(not(endwith(<space>)))))}")	predFormula="?{startwith(not(contain(not(endwith(<space>)))))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=92	correctMaxBeamPosition=92	correctMaxUnsortedBeamPosition=224	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=169	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=1	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=26	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=1	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(<let>),concat(or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>))))))))),<_>)}")	predFormula="?{star(<let>),concat(or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>))))))))),<_>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=26	correctMaxBeamPosition=26	correctMaxUnsortedBeamPosition=693	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5205	maxCellSize=1778	fallOffBeam=1	totalDerivs=236397	numOfFeaturizedDerivs=236397
iter=1	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=103	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=1	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(star(<num>),?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(star(<num>),?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=1232	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=237	maxCellSize=1278	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=1	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=58	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=1	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<any>})	predFormula=?{<any>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=1	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,4)},<.>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,4)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=1	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=50	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=1	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=230	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=1	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{repeat(<let>,3)}")	predFormula="?{repeat(<let>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=205	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=1	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=13	correctMaxBeamPosition=13	correctMaxUnsortedBeamPosition=339	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=269	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=1	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=9	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=1	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=15	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=1	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(sep(?{<num>},<_>),<_>)")	predFormula="sep(sep(?{<num>},<_>),<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=364	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=1	group=train	correct=0.266	oracle=0.565	partCorrect=0.266	partOracle=0.565	correctIndexAfterParse=10.886	correctMaxBeamPosition=10.914	correctMaxUnsortedBeamPosition=150.914	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.565	numPartialCorrect=0	numIncorrect=107.758	numTokens=27.694	parseTime=1742.419	maxCellSize=1637.435	fallOffBeam=0.452	totalDerivs=102771.613	numOfFeaturizedDerivs=102771.613
iter=2	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=2	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "and(concat(?{<num>,repeat(<num>,4)},?{or(<num>,<,>)}),sep(?{concat(repeat(<num>,5),repeat(<num>,2)),<num>},<.>))")	predFormula="and(concat(?{<num>,repeat(<num>,4)},?{or(<num>,<,>)}),sep(?{concat(repeat(<num>,5),repeat(<num>,2)),<num>},<.>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=39	parseTime=32389	maxCellSize=33091	fallOffBeam=1	totalDerivs=2308043	numOfFeaturizedDerivs=2308043
iter=2	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(?{<num>},?{repeat(<num>,15),<,>})")	predFormula="concat(?{<num>},?{repeat(<num>,15),<,>})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=174	correctMaxBeamPosition=174	correctMaxUnsortedBeamPosition=822	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2124	maxCellSize=1681	fallOffBeam=1	totalDerivs=168522	numOfFeaturizedDerivs=168522
iter=2	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(?{or(repeat(<num>,1),repeat(<num>,2))},?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(?{or(repeat(<num>,1),repeat(<num>,2))},?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=519	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=2	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=21	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=2	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=18	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=2	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "and(concat(?{repeatrange(<num>,1,18)},?{<num>}),sep(?{<num>},<.>))")	predFormula="and(concat(?{repeatrange(<num>,1,18)},?{<num>}),sep(?{<num>},<.>))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=18	correctMaxBeamPosition=18	correctMaxUnsortedBeamPosition=122	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2124	maxCellSize=2959	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=2	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<alphanum>,<any>,<_>})	predFormula=?{<alphanum>,<any>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=143	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=2	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=2	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=18	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=2	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->,<any>})	predFormula=?{<num>,<->,<any>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=14	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=2	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{<alphanum>,<any>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<let>,or(<%>,or(<&>,<^>))}")	predFormula="?{<alphanum>,<any>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<let>,or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14420	maxCellSize=1477	fallOffBeam=1	totalDerivs=420859	numOfFeaturizedDerivs=420859
iter=2	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "and(?{<any>,or(<let>,or(<num>,<space>))},?{<any>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))})")	predFormula="and(?{<any>,or(<let>,or(<num>,<space>))},?{<any>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=40	correctMaxBeamPosition=40	correctMaxUnsortedBeamPosition=180	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=172	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=2	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=2	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<num>,<any>}")	predFormula="?{endwith(<%>),<num>,<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=19	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=2	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<any>,6),<let>,<num>}")	predFormula="?{repeat(<any>,6),<let>,<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=2	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(concat(?{startwith(repeat(<hex>,8)),<any>},?{<_>}),?{<num>,<any>})")	predFormula="concat(concat(?{startwith(repeat(<hex>,8)),<any>},?{<_>}),?{<num>,<any>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1669	maxCellSize=2950	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=2	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=2	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(?{<any>,<let>,or(<uppera>,or(<upperb>,<upperc>))},?{repeat(<any>,3),<num>})")	predFormula="concat(?{<any>,<let>,or(<uppera>,or(<upperb>,<upperc>))},?{repeat(<any>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1499	maxCellSize=4762	fallOffBeam=1	totalDerivs=148591	numOfFeaturizedDerivs=148591
iter=2	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>,<alphanum>},<,>)")	predFormula="sep(?{<any>,<alphanum>},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=14	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=2	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=2	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<num>,<space>,<any>},<space>)")	predFormula="sep(?{<num>,<space>,<any>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=30	correctMaxBeamPosition=30	correctMaxUnsortedBeamPosition=16	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=277	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=2	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=40	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=2	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<spec>,<let>})	predFormula=?{<num>,<spec>,<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=22	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=2	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name ?{<any>,</>,<num>})	predFormula=?{<any>,</>,<num>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=2	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{<num>,<any>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{<num>,<any>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=24	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=2	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{<num>,repeat(<any>,3),concat(<0>,repeat(<any>,20))}")	predFormula="?{<num>,repeat(<any>,3),concat(<0>,repeat(<any>,20))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=969	maxCellSize=2849	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=2	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{<any>,or(<uppera>,<upperb>)}")	predFormula="?{<any>,or(<uppera>,<upperb>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=88	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=2	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{<num>,repeatatleast(<num>,10),<$>}")	predFormula="?{<num>,repeatatleast(<num>,10),<$>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=130	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=2	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<let>,concat(not(contain(<+>)),<spec>)},startwith(<+>))")	predFormula="sep(?{<let>,concat(not(contain(<+>)),<spec>)},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4988	maxCellSize=12614	fallOffBeam=1	totalDerivs=383894	numOfFeaturizedDerivs=383894
iter=2	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<any>,6),repeat(<any>,3),<num>,repeat(<any>,2),<space>}")	predFormula="?{repeat(<any>,6),repeat(<any>,3),<num>,repeat(<any>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=19	correctMaxBeamPosition=19	correctMaxUnsortedBeamPosition=593	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2940	maxCellSize=1274	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=2	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(concat(<upperc>,<0>)),endwith(repeat(<num>,4))}")	predFormula="?{startwith(concat(<upperc>,<0>)),endwith(repeat(<num>,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=25	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=2	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "and(?{<num>,repeat(<num>,2),<,>},?{<->,<num>})")	predFormula="and(?{<num>,repeat(<num>,2),<,>},?{<->,<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=224	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=2	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name "?{<any>,<alphanum>,or(<any>,<->)}")	predFormula="?{<any>,<alphanum>,or(<any>,<->)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=53	correctMaxBeamPosition=53	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=115	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=2	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{<num>,startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)")	predFormula="sep(?{<num>,startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10771	maxCellSize=4314	fallOffBeam=1	totalDerivs=519834	numOfFeaturizedDerivs=519834
iter=2	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{<any>,or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{<any>,or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=9	correctMaxBeamPosition=9	correctMaxUnsortedBeamPosition=245	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2546	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=2	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=2	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(?{<any>,repeat(<any>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{<num>})")	predFormula="concat(?{<any>,repeat(<any>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=43	parseTime=4303	maxCellSize=11035	fallOffBeam=1	totalDerivs=357297	numOfFeaturizedDerivs=357297
iter=2	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "not(contain(?{endwith(<spec>),repeatrange(<any>,3,25)}))")	predFormula="not(contain(?{endwith(<spec>),repeatrange(<any>,3,25)}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=67	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=306	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=2	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(contain(?{and(<%>,<%>),repeat(<any>,3),<%>,<any>}))")	predFormula="not(contain(?{and(<%>,<%>),repeat(<any>,3),<%>,<any>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1966	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=2	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=18	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=2	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>,<num>,<spec>})	predFormula=?{<let>,<num>,<spec>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=81	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=2	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(?{repeat(<any>,3),<any>,<let>,or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})")	predFormula="concat(?{repeat(<any>,3),<any>,<let>,or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=6738	maxCellSize=9247	fallOffBeam=1	totalDerivs=389364	numOfFeaturizedDerivs=389364
iter=2	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{<num>,concat(<num>,<num>),or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}")	predFormula="?{<num>,concat(<num>,<num>),or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8215	maxCellSize=1774	fallOffBeam=1	totalDerivs=291392	numOfFeaturizedDerivs=291392
iter=2	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=16	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=2	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=5	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=2	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,2),<%>}")	predFormula="?{repeat(<any>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=9	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=2	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=230	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=225	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=2	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{<any>,repeat(<num>,4),<space>}")	predFormula="?{<any>,repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=32	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=2	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{<any>,star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{<any>,star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=692	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5337	maxCellSize=1729	fallOffBeam=1	totalDerivs=236299	numOfFeaturizedDerivs=236299
iter=2	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=102	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=2	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{star(<num>),<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{star(<num>),<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=1253	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=331	maxCellSize=1300	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=2	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),<num>,startwith(<9>)}")	predFormula="?{repeat(<num>,10),<num>,startwith(<9>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=74	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=2	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>,<any>})	predFormula=?{<let>,<any>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=3	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=2	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,4)},<.>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,4)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=12	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=2	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=63	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=2	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=294	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=2	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{<let>,repeat(<num>,3),<any>}")	predFormula="?{<let>,repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=253	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=2	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "concat(?{<any>,not(contain(<any>)),<<>},?{notcc(<space>)})")	predFormula="concat(?{<any>,not(contain(<any>)),<<>},?{notcc(<space>)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=78	correctMaxBeamPosition=78	correctMaxUnsortedBeamPosition=343	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=326	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=2	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=11	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=2	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=19	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=2	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<num>,<any>},<_>)")	predFormula="sep(?{<num>,<any>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=28	correctMaxBeamPosition=28	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=426	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=2	group=train	correct=0.202	oracle=0.565	partCorrect=0.202	partOracle=0.565	correctIndexAfterParse=13.486	correctMaxBeamPosition=13.486	correctMaxUnsortedBeamPosition=145.400	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.565	numPartialCorrect=0	numIncorrect=107.758	numTokens=27.694	parseTime=1728.871	maxCellSize=1632.113	fallOffBeam=0.452	totalDerivs=102404.677	numOfFeaturizedDerivs=102404.677
iter=3	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=3	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{concat(repeat(<num>,5),repeat(or(<num>,<,>),4)),<num>},<.>)")	predFormula="sep(?{concat(repeat(<num>,5),repeat(or(<num>,<,>),4)),<num>},<.>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=96	correctMaxBeamPosition=96	correctMaxUnsortedBeamPosition=8168	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32798	maxCellSize=32862	fallOffBeam=1	totalDerivs=2325907	numOfFeaturizedDerivs=2325907
iter=3	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeat(<num>,15)})")	predFormula="concat(<num>,?{<,>,repeat(<num>,15)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=142	correctMaxBeamPosition=142	correctMaxUnsortedBeamPosition=709	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2111	maxCellSize=1679	fallOffBeam=1	totalDerivs=168794	numOfFeaturizedDerivs=168794
iter=3	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=152	maxCellSize=517	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=3	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=19	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=3	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<space>})	predFormula=?{<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=15	correctMaxBeamPosition=15	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=18	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=3	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=123	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2098	maxCellSize=2860	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=3	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<_>})	predFormula=?{<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=142	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=3	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=3	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=9	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=3	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<->})	predFormula=?{<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=8	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=3	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14068	maxCellSize=1561	fallOffBeam=1	totalDerivs=425075	numOfFeaturizedDerivs=425075
iter=3	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=164	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=169	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=3	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=3	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<let>}")	predFormula="?{endwith(<%>),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=19	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=3	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<let>,6)}")	predFormula="?{repeat(<let>,6)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=3	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "?{concat(startwith(repeat(<let>,8)),<let>)}")	predFormula="?{concat(startwith(repeat(<let>,8)),<let>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1654	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=3	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=3	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<num>,3)})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<num>,3)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1481	maxCellSize=4768	fallOffBeam=1	totalDerivs=148631	numOfFeaturizedDerivs=148631
iter=3	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>},<,>)")	predFormula="sep(?{<any>},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=3	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=6	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=3	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<let>},<space>)")	predFormula="sep(?{<let>},<space>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=14	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=279	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=3	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=40	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=3	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=23	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=3	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=3	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=24	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=3	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<let>,3),<0>}")	predFormula="?{repeat(<let>,3),<0>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=951	maxCellSize=2870	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=3	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=85	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=3	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=127	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=3	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<+>},startwith(<+>))")	predFormula="sep(?{<+>},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4881	maxCellSize=12457	fallOffBeam=1	totalDerivs=383810	numOfFeaturizedDerivs=383810
iter=3	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeat(<let>,2)}")	predFormula="?{repeat(<let>,6),repeat(<let>,2)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=593	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2888	maxCellSize=1252	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=3	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(concat(<upperc>,<0>))}")	predFormula="?{startwith(concat(<upperc>,<0>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=26	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=3	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{repeatatleast(<num>,1),<->},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=228	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=3	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=116	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=3	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "?{startwith(concat(<0>,<7>)),startwith(concat(<4>,concat(<4>,<7>)))}")	predFormula="?{startwith(concat(<0>,<7>)),startwith(concat(<4>,concat(<4>,<7>)))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10646	maxCellSize=4293	fallOffBeam=1	totalDerivs=519882	numOfFeaturizedDerivs=519882
iter=3	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{<.>,or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predFormula="?{<.>,or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=252	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2542	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=3	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{or(repeat(<num>,7),repeat(<num>,10))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=3	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "?{repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),repeat(<num>,6))}")	predFormula="?{repeat(<let>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),repeat(<num>,6))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=71	correctMaxBeamPosition=71	correctMaxUnsortedBeamPosition=601	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4289	maxCellSize=11027	fallOffBeam=1	totalDerivs=357531	numOfFeaturizedDerivs=357531
iter=3	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=306	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=3	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(contain(?{repeat(<let>,3),<%>}))")	predFormula="not(contain(?{repeat(<let>,3),<%>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1942	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=3	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=16	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=3	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=80	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=3	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "?{repeat(<let>,3),concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),repeatrange(<let>,1,2))}")	predFormula="?{repeat(<let>,3),concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),repeatrange(<let>,1,2))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=10	correctMaxBeamPosition=10	correctMaxUnsortedBeamPosition=857	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6695	maxCellSize=9248	fallOffBeam=1	totalDerivs=390280	numOfFeaturizedDerivs=390280
iter=3	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}")	predFormula="?{or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8226	maxCellSize=1799	fallOffBeam=1	totalDerivs=291430	numOfFeaturizedDerivs=291430
iter=3	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=8	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=3	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=3	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<let>,2),<%>}")	predFormula="?{repeat(<let>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=11	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=3	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(endwith(<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=216	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=248	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=3	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name ?{<space>})	predFormula=?{<space>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=32	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=3	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=692	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5517	maxCellSize=1760	fallOffBeam=1	totalDerivs=236369	numOfFeaturizedDerivs=236369
iter=3	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=170	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=3	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "?{concat(<upperx>,repeatatleast(<num>,1))}")	predFormula="?{concat(<upperx>,repeatatleast(<num>,1))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=6	correctMaxBeamPosition=6	correctMaxUnsortedBeamPosition=1233	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=303	maxCellSize=1279	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=3	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=74	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=3	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=3	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{repeatrange(<num>,1,4)}")	predFormula="?{repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=12	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=3	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<num>,2)}")	predFormula="?{repeat(<num>,2)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=31	correctMaxBeamPosition=31	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=63	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=3	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=294	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=3	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{repeat(<let>,3)}")	predFormula="?{repeat(<let>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=253	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=3	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=340	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=321	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=3	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=10	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=3	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=15	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=3	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<let>},<_>)")	predFormula="sep(?{<let>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=362	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=3	group=train	correct=0.331	oracle=0.613	partCorrect=0.331	partOracle=0.613	correctIndexAfterParse=11.026	correctMaxBeamPosition=11.026	correctMaxUnsortedBeamPosition=383	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.613	numPartialCorrect=0	numIncorrect=107.710	numTokens=27.694	parseTime=1724.839	maxCellSize=1625.742	fallOffBeam=0.452	totalDerivs=102785.548	numOfFeaturizedDerivs=102785.548
iter=4	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=4	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "concat(sep(?{repeatrange(<num>,1,5),<num>},<.>),sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>))")	predFormula="concat(sep(?{repeatrange(<num>,1,5),<num>},<.>),sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=149	correctMaxBeamPosition=149	correctMaxUnsortedBeamPosition=8059	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32307	maxCellSize=33044	fallOffBeam=1	totalDerivs=2315375	numOfFeaturizedDerivs=2315375
iter=4	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeatrange(<num>,1,15)})")	predFormula="concat(<num>,?{<,>,repeatrange(<num>,1,15)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=12	correctMaxBeamPosition=12	correctMaxUnsortedBeamPosition=708	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2095	maxCellSize=1679	fallOffBeam=1	totalDerivs=168598	numOfFeaturizedDerivs=168598
iter=4	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=519	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=4	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=19	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=4	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=4	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=122	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2100	maxCellSize=2887	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=4	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<space>,<_>})	predFormula=?{<space>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=142	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=4	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=4	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=10	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=4	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->})	predFormula=?{<num>,<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=4	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14326	maxCellSize=1523	fallOffBeam=1	totalDerivs=423033	numOfFeaturizedDerivs=423033
iter=4	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predFormula="?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=168	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=171	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=4	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=4	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<num>}")	predFormula="?{endwith(<%>),<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=20	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=4	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<let>,6),<num>}")	predFormula="?{repeat(<let>,6),<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=17	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=4	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<num>)})")	predFormula="concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<num>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1678	maxCellSize=2950	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=4	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=4	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1512	maxCellSize=4765	fallOffBeam=1	totalDerivs=148663	numOfFeaturizedDerivs=148663
iter=4	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<alphanum>},<,>)")	predFormula="sep(?{<alphanum>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=4	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=6	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=4	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<any>,<space>},<space>)")	predFormula="sep(?{<any>,<space>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=280	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=4	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "?{not(contain(<.>)),<.>}")	predFormula="?{not(contain(<.>)),<.>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=41	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=4	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<let>})	predFormula=?{<num>,<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=23	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=4	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=4	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=25	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=4	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,3),repeat(<any>,20),<0>}")	predFormula="?{repeat(<any>,3),repeat(<any>,20),<0>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=959	maxCellSize=2888	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=4	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=85	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=4	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=129	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=4	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{not(contain(not(contain(<+>))))},startwith(<+>))")	predFormula="sep(?{not(contain(not(contain(<+>))))},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4947	maxCellSize=12444	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=4	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<any>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predFormula="?{repeat(<any>,6),repeat(<num>,3),repeat(<let>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=595	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2878	maxCellSize=1273	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=4	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(concat(<upperc>,<0>)),endwith(repeatrange(<num>,1,4))}")	predFormula="?{startwith(concat(<upperc>,<0>)),endwith(repeatrange(<num>,1,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=25	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=4	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "?{repeat(<num>,2),<,>,<->}")	predFormula="?{repeat(<num>,2),<,>,<->}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=228	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=4	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<alphanum>,<->})	predFormula=?{<alphanum>,<->}	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=119	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=4	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)")	predFormula="sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>))),concat(<+>,concat(<4>,<4>))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10686	maxCellSize=4287	fallOffBeam=1	totalDerivs=519444	numOfFeaturizedDerivs=519444
iter=4	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=256	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2557	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=4	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=4	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(?{repeat(<any>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeatrange(<num>,1,6)})")	predFormula="concat(?{repeat(<any>,9),startwith(concat(<uppers>,concat(<uppero>,<->))),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeatrange(<num>,1,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=105	correctMaxBeamPosition=105	correctMaxUnsortedBeamPosition=594	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4418	maxCellSize=11035	fallOffBeam=1	totalDerivs=357321	numOfFeaturizedDerivs=357321
iter=4	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=306	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=4	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "?{not(contain(<%>)),repeat(<any>,3),<%>}")	predFormula="?{not(contain(<%>)),repeat(<any>,3),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1942	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=4	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=4	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>,<num>})	predFormula=?{<let>,<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=80	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=4	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(?{repeat(<let>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})")	predFormula="concat(?{repeat(<let>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=16	correctMaxBeamPosition=16	correctMaxUnsortedBeamPosition=866	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6534	maxCellSize=9218	fallOffBeam=1	totalDerivs=389798	numOfFeaturizedDerivs=389798
iter=4	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}")	predFormula="?{or(<1>,<2>),repeat(<num>,2),startwith(startwith(<0>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8300	maxCellSize=1774	fallOffBeam=1	totalDerivs=291340	numOfFeaturizedDerivs=291340
iter=4	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=8	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=4	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=4	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,2),<%>}")	predFormula="?{repeat(<any>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=5	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=4	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=215	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=168	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=4	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=26	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=4	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=699	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5232	maxCellSize=1739	fallOffBeam=1	totalDerivs=236321	numOfFeaturizedDerivs=236321
iter=4	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=105	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=4	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1236	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=243	maxCellSize=1283	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=4	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=58	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=4	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=4	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{<num>,repeatrange(<num>,1,4)}")	predFormula="?{<num>,repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=9	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=4	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeatrange(<num>,1,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeatrange(<num>,1,8)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=50	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=4	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=231	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=4	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{<let>,repeat(<num>,3)}")	predFormula="?{<let>,repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=203	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=4	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{<any>,concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{<any>,concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=261	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=4	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=4	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=14	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=4	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<_>,<num>},<_>)")	predFormula="sep(?{<_>,<num>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=9	correctMaxBeamPosition=9	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=357	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=4	group=train	correct=0.379	oracle=0.613	partCorrect=0.379	partOracle=0.613	correctIndexAfterParse=8.447	correctMaxBeamPosition=8.474	correctMaxUnsortedBeamPosition=380.684	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.613	numPartialCorrect=0	numIncorrect=107.710	numTokens=27.694	parseTime=1712.968	maxCellSize=1627.806	fallOffBeam=0.452	totalDerivs=102559.710	numOfFeaturizedDerivs=102559.710
iter=5	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=5	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=5	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predFormula="sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8147	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32449	maxCellSize=32788	fallOffBeam=1	totalDerivs=2322529	numOfFeaturizedDerivs=2322529
iter=5	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeatrange(<num>,1,15)})")	predFormula="concat(<num>,?{<,>,repeatrange(<num>,1,15)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=62	correctMaxBeamPosition=62	correctMaxUnsortedBeamPosition=713	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2102	maxCellSize=1679	fallOffBeam=1	totalDerivs=168808	numOfFeaturizedDerivs=168808
iter=5	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=517	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=5	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=5	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=10	correctMaxBeamPosition=10	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=5	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=121	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2110	maxCellSize=2864	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=5	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<_>})	predFormula=?{<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=145	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=5	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=5	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=10	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=5	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<->})	predFormula=?{<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=8	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=5	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14427	maxCellSize=1551	fallOffBeam=1	totalDerivs=424509	numOfFeaturizedDerivs=424509
iter=5	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=165	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=168	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=5	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=5	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<let>}")	predFormula="?{endwith(<%>),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=19	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=5	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeatrange(<let>,1,6)}")	predFormula="?{repeatrange(<let>,1,6)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=5	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<let>)})")	predFormula="concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<let>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1646	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=5	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=18	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=5	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeatrange(<num>,1,3)})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeatrange(<num>,1,3)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1525	maxCellSize=4764	fallOffBeam=1	totalDerivs=148621	numOfFeaturizedDerivs=148621
iter=5	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>},<,>)")	predFormula="sep(?{<any>},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=5	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=5	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<let>},<space>)")	predFormula="sep(?{<let>},<space>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=276	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=5	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=40	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=5	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=22	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=5	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=22	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=5	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=23	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=5	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{concat(<0>,repeat(<num>,3))}")	predFormula="?{concat(<0>,repeat(<num>,3))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=966	maxCellSize=2936	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=5	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=87	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=5	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=129	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=5	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<+>},startwith(<+>))")	predFormula="sep(?{<+>},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4927	maxCellSize=12438	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=5	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeatrange(<let>,1,2)}")	predFormula="?{repeat(<let>,6),repeatrange(<let>,1,2)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=23	correctMaxBeamPosition=23	correctMaxUnsortedBeamPosition=595	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2875	maxCellSize=1256	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=5	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(endwith(repeatrange(<num>,1,4)))}")	predFormula="?{startwith(endwith(repeatrange(<num>,1,4)))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=24	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=5	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=222	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=5	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=6	correctMaxBeamPosition=6	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=113	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=5	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "?{startwith(startwith(concat(<+>,concat(<4>,<4>))))}")	predFormula="?{startwith(startwith(concat(<+>,concat(<4>,<4>))))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10695	maxCellSize=4271	fallOffBeam=1	totalDerivs=519334	numOfFeaturizedDerivs=519334
iter=5	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{<.>,or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predFormula="?{<.>,or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=251	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2557	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=5	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{or(repeat(<num>,7),repeat(<num>,10))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=5	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})")	predFormula="concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=591	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4269	maxCellSize=11027	fallOffBeam=1	totalDerivs=357425	numOfFeaturizedDerivs=357425
iter=5	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=313	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=5	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(contain(?{repeat(<let>,3),<%>}))")	predFormula="not(contain(?{repeat(<let>,3),<%>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1966	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=5	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=5	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=81	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=5	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predFormula="concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=863	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6591	maxCellSize=9209	fallOffBeam=1	totalDerivs=390090	numOfFeaturizedDerivs=390090
iter=5	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "sep(?{<num>,or(<1>,<2>)},<.>)")	predFormula="sep(?{<num>,or(<1>,<2>)},<.>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=157	correctMaxBeamPosition=157	correctMaxUnsortedBeamPosition=1286	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=61	parseTime=8347	maxCellSize=1801	fallOffBeam=1	totalDerivs=291460	numOfFeaturizedDerivs=291460
iter=5	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=7	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=5	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=5	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<let>,2),<%>}")	predFormula="?{repeat(<let>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=5	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=5	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),<space>,not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),<space>,not(endwith(<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=213	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=168	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=5	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeatrange(<num>,1,4)}")	predFormula="?{repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=25	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=5	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=689	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5240	maxCellSize=1767	fallOffBeam=1	totalDerivs=236379	numOfFeaturizedDerivs=236379
iter=5	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeatrange(<num>,1,3)}")	predFormula="?{repeatrange(<num>,1,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=104	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=5	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(<num>,?{concat(<upperx>,repeatatleast(<num>,1))})")	predFormula="concat(<num>,?{concat(<upperx>,repeatatleast(<num>,1))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=1231	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=242	maxCellSize=1277	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=5	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=58	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=5	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=5	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{repeatrange(<num>,1,4)}")	predFormula="?{repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=9	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=5	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeatrange(<num>,1,2)}")	predFormula="?{repeatrange(<num>,1,2)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=19	correctMaxBeamPosition=19	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=48	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=5	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=228	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=5	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{repeat(<let>,3)}")	predFormula="?{repeat(<let>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=202	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=5	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=264	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=5	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=5	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=15	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=5	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<let>},<_>)")	predFormula="sep(?{<let>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=363	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=5	group=train	correct=0.355	oracle=0.629	partCorrect=0.355	partOracle=0.629	correctIndexAfterParse=7.538	correctMaxBeamPosition=7.564	correctMaxUnsortedBeamPosition=405.462	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.629	numPartialCorrect=0	numIncorrect=107.694	numTokens=27.694	parseTime=1716.403	maxCellSize=1624.339	fallOffBeam=0.452	totalDerivs=102709.097	numOfFeaturizedDerivs=102709.097
iter=6	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=6	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "concat(sep(?{repeatrange(<num>,1,5),<,>},<.>),sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>))")	predFormula="concat(sep(?{repeatrange(<num>,1,5),<,>},<.>),sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=8135	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=33844	maxCellSize=32965	fallOffBeam=1	totalDerivs=2314489	numOfFeaturizedDerivs=2314489
iter=6	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(?{<num>},?{repeat(<num>,3),<,>})")	predFormula="concat(?{<num>},?{repeat(<num>,3),<,>})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=709	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2134	maxCellSize=1679	fallOffBeam=1	totalDerivs=168582	numOfFeaturizedDerivs=168582
iter=6	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=153	maxCellSize=519	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=6	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=6	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=18	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=6	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=121	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2143	maxCellSize=2879	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=6	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<space>,<_>})	predFormula=?{<space>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=142	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=6	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=6	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=9	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=6	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->})	predFormula=?{<num>,<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=6	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14381	maxCellSize=1527	fallOffBeam=1	totalDerivs=423103	numOfFeaturizedDerivs=423103
iter=6	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predFormula="?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=168	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=170	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=6	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=6	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<num>}")	predFormula="?{endwith(<%>),<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=18	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=6	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<any>,6),<let>}")	predFormula="?{repeat(<any>,6),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=21	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=6	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{repeat(<hex>,8),<any>},concat(?{<_>},?{<num>,<any>}))")	predFormula="concat(?{repeat(<hex>,8),<any>},concat(?{<_>},?{<num>,<any>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1668	maxCellSize=2950	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=6	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=6	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1473	maxCellSize=4767	fallOffBeam=1	totalDerivs=148669	numOfFeaturizedDerivs=148669
iter=6	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<alphanum>},<,>)")	predFormula="sep(?{<alphanum>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=14	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=6	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=6	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<any>,<space>},<space>)")	predFormula="sep(?{<any>,<space>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=277	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=6	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=41	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=6	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<spec>})	predFormula=?{<num>,<spec>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=22	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=6	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=6	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=23	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=6	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,3),repeat(<any>,20),<0>}")	predFormula="?{repeat(<any>,3),repeat(<any>,20),<0>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=969	maxCellSize=2885	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=6	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{<any>,or(<uppera>,<upperb>)}")	predFormula="?{<any>,or(<uppera>,<upperb>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=84	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=6	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=128	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=6	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<let>,concat(<+>,<spec>)},startwith(<+>))")	predFormula="sep(?{<let>,concat(<+>,<spec>)},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4937	maxCellSize=12425	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=6	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}")	predFormula="?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=593	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2887	maxCellSize=1271	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=6	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{concat(<upperc>,<0>),endwith(repeat(<num>,4))}")	predFormula="?{concat(<upperc>,<0>),endwith(repeat(<num>,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=24	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=6	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=223	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=6	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<alphanum>,<->})	predFormula=?{<alphanum>,<->}	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=114	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=6	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<+>,concat(<4>,<4>)))},<num>)")	predFormula="sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<+>,concat(<4>,<4>)))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10724	maxCellSize=4261	fallOffBeam=1	totalDerivs=518908	numOfFeaturizedDerivs=518908
iter=6	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=251	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2561	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=6	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=6	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})")	predFormula="concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=92	correctMaxBeamPosition=92	correctMaxUnsortedBeamPosition=590	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4293	maxCellSize=11035	fallOffBeam=1	totalDerivs=357287	numOfFeaturizedDerivs=357287
iter=6	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=307	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=6	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "?{not(contain(<%>)),repeat(<any>,3),<%>}")	predFormula="?{not(contain(<%>)),repeat(<any>,3),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1989	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=6	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=16	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=6	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>,<num>})	predFormula=?{<let>,<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=79	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=6	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})")	predFormula="concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=31	correctMaxBeamPosition=31	correctMaxUnsortedBeamPosition=860	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6576	maxCellSize=9230	fallOffBeam=1	totalDerivs=389886	numOfFeaturizedDerivs=389886
iter=6	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{or(<1>,<2>),repeat(<num>,2),startwith(<0>)}")	predFormula="?{or(<1>,<2>),repeat(<num>,2),startwith(<0>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=61	parseTime=8350	maxCellSize=1775	fallOffBeam=1	totalDerivs=291358	numOfFeaturizedDerivs=291358
iter=6	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=7	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=6	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=6	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,2),<%>}")	predFormula="?{repeat(<any>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=5	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=6	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=213	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=169	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=6	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=25	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=6	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=694	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5256	maxCellSize=1750	fallOffBeam=1	totalDerivs=236343	numOfFeaturizedDerivs=236343
iter=6	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=105	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=6	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1237	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=238	maxCellSize=1285	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=6	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=58	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=6	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=3	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=6	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{<num>,repeatrange(<num>,1,4)}")	predFormula="?{<num>,repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=6	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=50	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=6	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=345	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=6	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{<let>,repeat(<num>,3)}")	predFormula="?{<let>,repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=254	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=6	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{<any>,concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{<any>,concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=322	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=6	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=10	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=6	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=18	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=6	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<num>,<_>},<_>)")	predFormula="sep(?{<num>,<_>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=8	correctMaxBeamPosition=8	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=453	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=6	group=train	correct=0.395	oracle=0.613	partCorrect=0.395	partOracle=0.613	correctIndexAfterParse=4.763	correctMaxBeamPosition=4.763	correctMaxUnsortedBeamPosition=382.079	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.613	numPartialCorrect=0	numIncorrect=107.710	numTokens=27.694	parseTime=1745.548	maxCellSize=1626.113	fallOffBeam=0.452	totalDerivs=102539.258	numOfFeaturizedDerivs=102539.258
iter=7	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=7	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predFormula="sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8163	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=33075	maxCellSize=32761	fallOffBeam=1	totalDerivs=2321665	numOfFeaturizedDerivs=2321665
iter=7	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeat(<num>,15)})")	predFormula="concat(<num>,?{<,>,repeat(<num>,15)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=60	correctMaxBeamPosition=60	correctMaxUnsortedBeamPosition=711	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2120	maxCellSize=1679	fallOffBeam=1	totalDerivs=168780	numOfFeaturizedDerivs=168780
iter=7	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=158	maxCellSize=517	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=7	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=19	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=7	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<space>})	predFormula=?{<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=10	correctMaxBeamPosition=10	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=7	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=120	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2125	maxCellSize=2862	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=7	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<_>})	predFormula=?{<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=140	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=7	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=7	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=9	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=7	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<->})	predFormula=?{<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=7	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14387	maxCellSize=1554	fallOffBeam=1	totalDerivs=424937	numOfFeaturizedDerivs=424937
iter=7	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=164	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=173	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=7	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name ?{<space>})	predFormula=?{<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=7	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<let>}")	predFormula="?{endwith(<%>),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=19	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=7	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<let>,6)}")	predFormula="?{repeat(<let>,6)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=7	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<let>)})")	predFormula="concat(?{startwith(repeatrange(<hex>,1,8))},?{concat(<_>,<let>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1661	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=7	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=7	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<num>,3)})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<num>,3)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1472	maxCellSize=4765	fallOffBeam=1	totalDerivs=148655	numOfFeaturizedDerivs=148655
iter=7	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<any>},<,>)")	predFormula="sep(?{<any>},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=15	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=7	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=7	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<let>},<space>)")	predFormula="sep(?{<let>},<space>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=279	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=7	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=41	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=7	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=23	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=7	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=7	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=24	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=7	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{concat(<0>,repeat(<num>,3))}")	predFormula="?{concat(<0>,repeat(<num>,3))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=959	maxCellSize=2936	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=7	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=85	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=7	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=127	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=7	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<+>},startwith(<+>))")	predFormula="sep(?{<+>},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4955	maxCellSize=12428	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=7	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2)}")	predFormula="?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=595	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2880	maxCellSize=1256	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=7	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{startwith(endwith(repeatrange(<num>,1,4)))}")	predFormula="?{startwith(endwith(repeatrange(<num>,1,4)))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=24	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=7	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=224	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=7	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=115	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=7	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "?{startwith(<0>),startwith(concat(<+>,concat(<4>,<4>)))}")	predFormula="?{startwith(<0>),startwith(concat(<+>,concat(<4>,<4>)))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10679	maxCellSize=4269	fallOffBeam=1	totalDerivs=519370	numOfFeaturizedDerivs=519370
iter=7	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=255	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2583	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=7	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{or(repeat(<num>,7),repeat(<num>,10))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=7	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})")	predFormula="concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=584	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4326	maxCellSize=11037	fallOffBeam=1	totalDerivs=357517	numOfFeaturizedDerivs=357517
iter=7	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=308	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=7	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "?{repeat(<let>,3),<%>}")	predFormula="?{repeat(<let>,3),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1980	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=7	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=16	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=7	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=79	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=7	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predFormula="concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=854	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6544	maxCellSize=9226	fallOffBeam=1	totalDerivs=390056	numOfFeaturizedDerivs=390056
iter=7	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "sep(?{<num>,or(<1>,<2>)},<.>)")	predFormula="sep(?{<num>,or(<1>,<2>)},<.>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=58	correctMaxBeamPosition=58	correctMaxUnsortedBeamPosition=1272	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=61	parseTime=8309	maxCellSize=1783	fallOffBeam=1	totalDerivs=291392	numOfFeaturizedDerivs=291392
iter=7	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=9	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=7	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=4	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=7	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<let>,2),<%>}")	predFormula="?{repeat(<let>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=5	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=7	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=213	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=169	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=7	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=25	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=7	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=693	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5265	maxCellSize=1762	fallOffBeam=1	totalDerivs=236371	numOfFeaturizedDerivs=236371
iter=7	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3)}")	predFormula="?{repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=102	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=7	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(<num>,?{concat(<upperx>,repeatatleast(<num>,1))})")	predFormula="concat(<num>,?{concat(<upperx>,repeatatleast(<num>,1))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=3	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=1233	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=241	maxCellSize=1279	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=7	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=59	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=7	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=7	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{repeatrange(<num>,1,4)}")	predFormula="?{repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=7	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<num>,2),repeat(<num>,8)}")	predFormula="?{repeat(<num>,2),repeat(<num>,8)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=50	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=7	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=237	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=7	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{repeat(<let>,3)}")	predFormula="?{repeat(<let>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=201	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=7	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "?{concat(<<>,notcc(<space>))}")	predFormula="?{concat(<<>,notcc(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=259	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=7	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=9	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=7	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=14	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=7	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<_>},<_>)")	predFormula="sep(?{<_>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=359	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=7	group=train	correct=0.387	oracle=0.629	partCorrect=0.387	partOracle=0.629	correctIndexAfterParse=3.795	correctMaxBeamPosition=3.897	correctMaxUnsortedBeamPosition=405.256	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.629	numPartialCorrect=0	numIncorrect=107.694	numTokens=27.694	parseTime=1726.597	maxCellSize=1623.839	fallOffBeam=0.452	totalDerivs=102702.452	numOfFeaturizedDerivs=102702.452
iter=8	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=8	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predFormula="sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8112	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32499	maxCellSize=32812	fallOffBeam=1	totalDerivs=2316095	numOfFeaturizedDerivs=2316095
iter=8	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeat(<num>,3)})")	predFormula="concat(<num>,?{<,>,repeat(<num>,3)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=10	correctMaxBeamPosition=10	correctMaxUnsortedBeamPosition=708	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2128	maxCellSize=1679	fallOffBeam=1	totalDerivs=168612	numOfFeaturizedDerivs=168612
iter=8	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=517	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=8	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=8	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<let>,<space>})	predFormula=?{<let>,<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=8	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=120	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2132	maxCellSize=2872	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=8	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<space>,<_>})	predFormula=?{<space>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=144	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=8	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=8	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=9	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=8	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->})	predFormula=?{<num>,<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=8	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14358	maxCellSize=1533	fallOffBeam=1	totalDerivs=423361	numOfFeaturizedDerivs=423361
iter=8	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predFormula="?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=166	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=171	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=8	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=8	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<num>}")	predFormula="?{endwith(<%>),<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=29	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=8	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<any>,6),<let>}")	predFormula="?{repeat(<any>,6),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=29	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=8	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{repeat(<hex>,8),<any>},?{concat(<_>,<num>)})")	predFormula="concat(?{repeat(<hex>,8),<any>},?{concat(<_>,<num>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=2011	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=8	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=12	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=8	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1475	maxCellSize=4767	fallOffBeam=1	totalDerivs=148707	numOfFeaturizedDerivs=148707
iter=8	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<alphanum>},<,>)")	predFormula="sep(?{<alphanum>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=14	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=8	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=6	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=8	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<any>,<space>},<space>)")	predFormula="sep(?{<any>,<space>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=278	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=8	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=42	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=8	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<spec>})	predFormula=?{<num>,<spec>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=23	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=8	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=8	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=24	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=8	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,3),repeat(<any>,20),<0>}")	predFormula="?{repeat(<any>,3),repeat(<any>,20),<0>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=967	maxCellSize=2921	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=8	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=85	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=8	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=129	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=8	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<let>,<+>},startwith(<+>))")	predFormula="sep(?{<let>,<+>},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=5220	maxCellSize=12422	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=8	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}")	predFormula="?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=595	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2920	maxCellSize=1266	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=8	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{concat(<upperc>,<0>),endwith(repeatrange(<num>,1,4))}")	predFormula="?{concat(<upperc>,<0>),endwith(repeatrange(<num>,1,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=25	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=8	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=228	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=8	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<alphanum>,<->})	predFormula=?{<alphanum>,<->}	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=116	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=8	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<+>,concat(<4>,<4>)))},<num>)")	predFormula="sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<+>,concat(<4>,<4>)))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10683	maxCellSize=4257	fallOffBeam=1	totalDerivs=518912	numOfFeaturizedDerivs=518912
iter=8	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=253	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2561	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=8	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=8	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})")	predFormula="concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=20	correctMaxBeamPosition=20	correctMaxUnsortedBeamPosition=586	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4301	maxCellSize=11027	fallOffBeam=1	totalDerivs=357337	numOfFeaturizedDerivs=357337
iter=8	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=307	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=8	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "?{not(contain(<%>)),repeat(<any>,3),<%>}")	predFormula="?{not(contain(<%>)),repeat(<any>,3),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1998	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=8	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=8	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>,<num>})	predFormula=?{<let>,<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=80	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=8	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})")	predFormula="concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=13	correctMaxBeamPosition=13	correctMaxUnsortedBeamPosition=858	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6564	maxCellSize=9217	fallOffBeam=1	totalDerivs=389900	numOfFeaturizedDerivs=389900
iter=8	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "?{or(<1>,<2>),repeat(<num>,2),startwith(<0>)}")	predFormula="?{or(<1>,<2>),repeat(<num>,2),startwith(<0>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=73	correctMaxBeamPosition=73	correctMaxUnsortedBeamPosition=1256	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=61	parseTime=8321	maxCellSize=1758	fallOffBeam=1	totalDerivs=291288	numOfFeaturizedDerivs=291288
iter=8	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=7	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=8	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=8	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,2),<%>}")	predFormula="?{repeat(<any>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=6	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=8	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=209	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=168	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=8	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=25	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=8	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=695	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5237	maxCellSize=1750	fallOffBeam=1	totalDerivs=236343	numOfFeaturizedDerivs=236343
iter=8	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3),<any>}")	predFormula="?{repeat(<num>,3),<any>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=105	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=8	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1237	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=236	maxCellSize=1284	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=8	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=57	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=8	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=8	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{<num>,repeatrange(<num>,1,4)}")	predFormula="?{<num>,repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=8	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=49	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=8	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=229	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=8	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{<let>,repeat(<num>,3)}")	predFormula="?{<let>,repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=201	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=8	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{<any>,concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{<any>,concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=259	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=8	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=8	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=14	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=8	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<_>,<num>},<_>)")	predFormula="sep(?{<_>,<num>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=358	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=8	group=train	correct=0.419	oracle=0.629	partCorrect=0.419	partOracle=0.629	correctIndexAfterParse=3.897	correctMaxBeamPosition=3.974	correctMaxUnsortedBeamPosition=403.667	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.629	numPartialCorrect=0	numIncorrect=107.694	numTokens=27.694	parseTime=1727.597	maxCellSize=1623.323	fallOffBeam=0.452	totalDerivs=102570.387	numOfFeaturizedDerivs=102570.387
iter=9	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=6	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=9	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predFormula="sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8146	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32811	maxCellSize=32766	fallOffBeam=1	totalDerivs=2320701	numOfFeaturizedDerivs=2320701
iter=9	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>})")	predFormula="concat(<num>,?{<,>})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=42	correctMaxBeamPosition=42	correctMaxUnsortedBeamPosition=714	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2133	maxCellSize=1679	fallOffBeam=1	totalDerivs=168766	numOfFeaturizedDerivs=168766
iter=9	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=151	maxCellSize=517	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=9	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=20	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=9	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<space>})	predFormula=?{<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=9	correctMaxBeamPosition=9	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=9	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=120	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2119	maxCellSize=2866	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=9	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<_>})	predFormula=?{<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=140	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=9	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=9	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=9	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=9	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<->})	predFormula=?{<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=9	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<%>,or(<&>,<^>))}")	predFormula="?{or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14101	maxCellSize=1558	fallOffBeam=1	totalDerivs=425363	numOfFeaturizedDerivs=425363
iter=9	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>))}")	predFormula="?{or(<let>,or(<num>,<space>))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=163	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=178	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=9	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=9	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<let>}")	predFormula="?{endwith(<%>),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=18	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=9	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeatrange(<let>,1,6)}")	predFormula="?{repeatrange(<let>,1,6)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=9	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{repeatrange(<hex>,1,8)},?{concat(<_>,<let>)})")	predFormula="concat(?{repeatrange(<hex>,1,8)},?{concat(<_>,<let>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1648	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=9	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=9	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeatrange(<let>,1,3)})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeatrange(<let>,1,3)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1463	maxCellSize=4773	fallOffBeam=1	totalDerivs=148755	numOfFeaturizedDerivs=148755
iter=9	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<alphanum>},<,>)")	predFormula="sep(?{<alphanum>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=14	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=9	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=9	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<space>},<space>)")	predFormula="sep(?{<space>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=275	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=9	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=39	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=9	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=22	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=9	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=22	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=9	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=23	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=9	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{concat(<0>,repeat(<num>,3))}")	predFormula="?{concat(<0>,repeat(<num>,3))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=958	maxCellSize=2939	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=9	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=84	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=9	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=129	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=9	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "?{concat(<+>,<+>)}")	predFormula="?{concat(<+>,<+>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4886	maxCellSize=12432	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=9	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predFormula="?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=595	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=2861	maxCellSize=1257	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=9	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{endwith(repeatrange(<num>,1,4))}")	predFormula="?{endwith(repeatrange(<num>,1,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=24	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=9	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=221	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=9	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<->})	predFormula=?{<->}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=113	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=9	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "?{startwith(<0>)}")	predFormula="?{startwith(<0>)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10665	maxCellSize=4273	fallOffBeam=1	totalDerivs=519362	numOfFeaturizedDerivs=519362
iter=9	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=253	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2559	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=9	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{or(repeat(<num>,7),repeat(<num>,10))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=2	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=9	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})")	predFormula="concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeatrange(<num>,1,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=577	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4250	maxCellSize=11034	fallOffBeam=1	totalDerivs=357667	numOfFeaturizedDerivs=357667
iter=9	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=309	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=9	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "not(contain(?{repeat(<let>,3),<%>}))")	predFormula="not(contain(?{repeat(<let>,3),<%>}))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1952	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=9	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=9	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=80	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=9	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predFormula="concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=853	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6477	maxCellSize=9191	fallOffBeam=1	totalDerivs=390212	numOfFeaturizedDerivs=390212
iter=9	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,2)},<.>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,2)},<.>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=1277	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=61	parseTime=8228	maxCellSize=1787	fallOffBeam=1	totalDerivs=291404	numOfFeaturizedDerivs=291404
iter=9	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=7	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=9	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=3	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=9	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<let>,2),<%>}")	predFormula="?{repeat(<let>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=6	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=9	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=215	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=169	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=9	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=26	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=9	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=691	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5231	maxCellSize=1753	fallOffBeam=1	totalDerivs=236357	numOfFeaturizedDerivs=236357
iter=9	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{repeat(<num>,3)}")	predFormula="?{repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=101	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=9	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},?{concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{<num>},?{concat(<^>,repeatatleast(<num>,1))})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=1233	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=236	maxCellSize=1279	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=9	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),<9>}")	predFormula="?{repeat(<num>,10),<9>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=3	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=57	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=9	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=9	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "?{repeatrange(<num>,1,4)}")	predFormula="?{repeatrange(<num>,1,4)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=9	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<num>,2),repeat(<num>,8)}")	predFormula="?{repeat(<num>,2),repeat(<num>,8)}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=48	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=9	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=228	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=9	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{repeat(<let>,3)}")	predFormula="?{repeat(<let>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=200	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=9	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=261	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=9	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=9	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=15	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=9	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<_>},<_>)")	predFormula="sep(?{<_>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=364	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=9	group=train	correct=0.387	oracle=0.629	partCorrect=0.387	partOracle=0.629	correctIndexAfterParse=1.872	correctMaxBeamPosition=1.974	correctMaxUnsortedBeamPosition=404.744	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.629	numPartialCorrect=0	numIncorrect=107.694	numTokens=27.694	parseTime=1710.371	maxCellSize=1623.677	fallOffBeam=0.452	totalDerivs=102699.935	numOfFeaturizedDerivs=102699.935
iter=10	group=train	utterance=I need to validate each sub string length is 3 which is split by comma.	targetValue=(name "sep(?{repeat(<any>,3)},<,>)")	predValue=(name "sep(?{repeat(<any>,3)},<,>)")	predFormula="sep(?{repeat(<any>,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=1	numPartialCorrect=0	numIncorrect=6	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=795	numOfFeaturizedDerivs=795
iter=10	group=train	utterance=I want a regular expression for decimal input, which can take 4 digits before decimal or comma and 2 digits after decimal/comma. 5 digit number without decimal is invalid.Validation show also include comma along with decimal.	targetValue=(name "sep(?{repeatrange(<num>,1,4),repeatrange(<num>,1,2)},<.>)")	predValue=(name "and(sep(?{repeatrange(<num>,1,4),<,>},<.>),sep(?{repeatrange(<num>,1,2),<,>},<.>))")	predFormula="and(sep(?{repeatrange(<num>,1,4),<,>},<.>),sep(?{repeatrange(<num>,1,2),<,>},<.>))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=2	correctMaxBeamPosition=2	correctMaxUnsortedBeamPosition=8126	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=39	parseTime=32141	maxCellSize=32786	fallOffBeam=1	totalDerivs=2315403	numOfFeaturizedDerivs=2315403
iter=10	group=train	utterance=i need a Regular that validate Decimal (18,3) this mean max number of digits before comma is 15 and accept 3 numbers after comma . 18 precision 3 scale.	targetValue=(name "concat(?{<num>},?{<,>,repeatrange(<num>,1,3)})")	predValue=(name "concat(<num>,?{<,>,repeat(<num>,3)})")	predFormula="concat(<num>,?{<,>,repeat(<num>,3)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=14	correctMaxBeamPosition=14	correctMaxUnsortedBeamPosition=710	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=2126	maxCellSize=1679	fallOffBeam=1	totalDerivs=168584	numOfFeaturizedDerivs=168584
iter=10	group=train	utterance=i need regular expression for : one or two digits then leftquoatation . rightquoatation and one or two digits.	targetValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predValue=(name "concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})")	predFormula="concat(or(repeat(<num>,1),repeat(<num>,2)),?{<.>,or(repeat(<num>,1),repeat(<num>,2))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=148	maxCellSize=518	fallOffBeam=1	totalDerivs=14622	numOfFeaturizedDerivs=14622
iter=10	group=train	utterance=It should accept numbers only with decimal part leftquoatation 0 rightquoatation or leftquoatation 5 rightquoatation only.	targetValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predValue=(name "sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)")	predFormula="sep(?{repeatatleast(<num>,1),or(<0>,<5>)},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=9	parsed=1	numCandidates=32	parsedNumCandidates=32	numCorrect=1	numPartialCorrect=0	numIncorrect=31	numTokens=17	parseTime=19	maxCellSize=32	fallOffBeam=0	totalDerivs=2174	numOfFeaturizedDerivs=2174
iter=10	group=train	utterance=I am trying to make a regular expression that validates letters, numbers and spaces ONLY.	targetValue=(name ?{<let>,<num>,<space>})	predValue=(name ?{<let>,<space>})	predFormula=?{<let>,<space>}	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=21	parsed=1	numCandidates=30	parsedNumCandidates=30	numCorrect=1	numPartialCorrect=0	numIncorrect=29	numTokens=17	parseTime=17	maxCellSize=30	fallOffBeam=0	totalDerivs=2002	numOfFeaturizedDerivs=2002
iter=10	group=train	utterance=I want this value to accept up to 18 digits before the decimal, and 1 digit after. With the decimal point and the digit after it being optional	targetValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predValue=(name "sep(?{repeatrange(<num>,1,18),<num>},<.>)")	predFormula="sep(?{repeatrange(<num>,1,18),<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=121	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=30	parseTime=2109	maxCellSize=2874	fallOffBeam=1	totalDerivs=182087	numOfFeaturizedDerivs=182087
iter=10	group=train	utterance=Should allow only alphanumeric with no space and no other characters including leftquoatation _ rightquoatation. It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,<space>,<_>,not(startwith(<space>)),not(endwith(<space>))}")	predValue=(name ?{<space>,<_>})	predFormula=?{<space>,<_>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=115	parsedNumCandidates=115	numCorrect=0	numPartialCorrect=0	numIncorrect=115	numTokens=24	parseTime=140	maxCellSize=115	fallOffBeam=0	totalDerivs=11423	numOfFeaturizedDerivs=11423
iter=10	group=train	utterance=validate a set of double number with semi-colon delimited	targetValue=(name "sep(sep(?{<num>},<.>),<;>)")	predValue=(name "sep(sep(?{<num>},<.>),<;>)")	predFormula="sep(sep(?{<num>},<.>),<;>)"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=10	parseTime=3	maxCellSize=12	fallOffBeam=0	totalDerivs=419	numOfFeaturizedDerivs=419
iter=10	group=train	utterance=I'm trying to validate a value and that value cannot have a zero and then a number in front of it	targetValue=(name null)	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=0	numPartialCorrect=0	numIncorrect=3	numTokens=23	parseTime=10	maxCellSize=3	fallOffBeam=0	totalDerivs=1192	numOfFeaturizedDerivs=1192
iter=10	group=train	utterance=Requirement is that total number of leftquoatation - rightquoatation with the string can only be one	targetValue=(name null)	predValue=(name ?{<num>,<->})	predFormula=?{<num>,<->}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=7	parsedNumCandidates=7	numCorrect=0	numPartialCorrect=0	numIncorrect=7	numTokens=16	parseTime=7	maxCellSize=7	fallOffBeam=0	totalDerivs=969	numOfFeaturizedDerivs=969
iter=10	group=train	utterance=The input box should accept alphanumeric with no space and it should also allow the user to use the characters like leftquoatation enumconsts rightquoatation any where in the string, except these characters non of the other characters should be allowed like (leftquoatation % rightquoatation,  leftquoatation & rightquoatation, leftquoatation ^ rightquoatation etc). It should not allow leading/trailing whitespace also.	targetValue=(name "?{<alphanum>,concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}")	predFormula="?{concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),or(<%>,or(<&>,<^>))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=65	parseTime=14092	maxCellSize=1532	fallOffBeam=1	totalDerivs=423315	numOfFeaturizedDerivs=423315
iter=10	group=train	utterance=Allows only the following characters: Letters, numbers, spaces and any of the following characters leftquoatation enumconsts rightquoatation	targetValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predValue=(name "?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}")	predFormula="?{or(<let>,or(<num>,<space>)),concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=166	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=20	parseTime=167	maxCellSize=519	fallOffBeam=1	totalDerivs=16634	numOfFeaturizedDerivs=16634
iter=10	group=train	utterance=write regular expression in C# to validate that the input does not contain double spaces	targetValue=(name "not(contain(?{<space>}))")	predValue=(name "not(contain(?{<space>}))")	predFormula="not(contain(?{<space>}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=475	numOfFeaturizedDerivs=475
iter=10	group=train	utterance=start and finish with a percentage sign and can contain any number of characters in-between	targetValue=(name null)	predValue=(name "?{endwith(<%>),<num>}")	predFormula="?{endwith(<%>),<num>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=63	parsedNumCandidates=63	numCorrect=0	numPartialCorrect=0	numIncorrect=63	numTokens=16	parseTime=28	maxCellSize=63	fallOffBeam=0	totalDerivs=2387	numOfFeaturizedDerivs=2387
iter=10	group=train	utterance=What is the regex that matches 6 characters, first is a letter, others are numbers	targetValue=(name "concat(?{repeat(<any>,6),<let>,<num>},?{repeat(<any>,6),<let>,<num>})")	predValue=(name "?{repeat(<any>,6),<let>}")	predFormula="?{repeat(<any>,6),<let>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=25	parsedNumCandidates=25	numCorrect=0	numPartialCorrect=0	numIncorrect=25	numTokens=17	parseTime=16	maxCellSize=25	fallOffBeam=0	totalDerivs=2125	numOfFeaturizedDerivs=2125
iter=10	group=train	utterance=I want to validate if my input consists starting with 8 hexadecimal characters followed by a underscore, followed by any number of characters with any value.	targetValue=(name "concat(repeat(<hex>,8),concat(<_>,?{<let>}))")	predValue=(name "concat(?{repeat(<hex>,8),<any>},?{concat(<_>,<num>)})")	predFormula="concat(?{repeat(<hex>,8),<any>},?{concat(<_>,<num>)})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=1667	maxCellSize=2948	fallOffBeam=1	totalDerivs=146683	numOfFeaturizedDerivs=146683
iter=10	group=train	utterance=I need a regular expression that validates a number, but doesn't require a digit after the decimal	targetValue=(name "sep(?{<num>},<.>)")	predValue=(name "sep(?{<num>},<.>)")	predFormula="sep(?{<num>},<.>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=25	parsed=1	numCandidates=27	parsedNumCandidates=27	numCorrect=1	numPartialCorrect=0	numIncorrect=26	numTokens=19	parseTime=13	maxCellSize=27	fallOffBeam=0	totalDerivs=1510	numOfFeaturizedDerivs=1510
iter=10	group=train	utterance=The first character should be a designated character like leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation only. and the next 3 characters should be numbers.	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>)),repeat(<num>,3),<num>}")	predValue=(name "concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})")	predFormula="concat(or(<uppera>,or(<upperb>,<upperc>)),?{repeat(<any>,3),<num>})"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=1468	maxCellSize=4767	fallOffBeam=1	totalDerivs=148691	numOfFeaturizedDerivs=148691
iter=10	group=train	utterance=I need a regular expression that can validate that a string is an alphanumeric comma delimited string.	targetValue=(name "sep(?{<alphanum>},<,>)")	predValue=(name "sep(?{<alphanum>},<,>)")	predFormula="sep(?{<alphanum>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=21	parsedNumCandidates=21	numCorrect=1	numPartialCorrect=0	numIncorrect=20	numTokens=18	parseTime=14	maxCellSize=21	fallOffBeam=0	totalDerivs=1744	numOfFeaturizedDerivs=1744
iter=10	group=train	utterance=regular expression which validates only number and min length should be 11 and maximum 16	targetValue=(name null)	predValue=(name "?{repeat(<num>,11)}")	predFormula="?{repeat(<num>,11)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=4	parsedNumCandidates=4	numCorrect=0	numPartialCorrect=0	numIncorrect=4	numTokens=15	parseTime=5	maxCellSize=4	fallOffBeam=0	totalDerivs=799	numOfFeaturizedDerivs=799
iter=10	group=train	utterance=It should allow only one space between words. That is, total number of spaces between words or characters should only be one.It should ignore leading and trailing spaces.	targetValue=(name "sep(?{<let>},<space>)")	predValue=(name "sep(?{<any>,<space>},<space>)")	predFormula="sep(?{<any>,<space>},<space>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=4	correctMaxBeamPosition=4	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=31	parseTime=273	maxCellSize=485	fallOffBeam=1	totalDerivs=21663	numOfFeaturizedDerivs=21663
iter=10	group=train	utterance=I want to use a Regular expression validator in my line edit that doesn't allow to write dot(leftquoatation . rightquoatation) right after dot(leftquoatation . rightquoatation)	targetValue=(name "not(contain(?{concat(<.>,<.>)}))")	predValue=(name "not(contain(?{concat(<.>,<.>)}))")	predFormula="not(contain(?{concat(<.>,<.>)}))"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=29	parsed=1	numCandidates=33	parsedNumCandidates=33	numCorrect=1	numPartialCorrect=0	numIncorrect=32	numTokens=32	parseTime=40	maxCellSize=33	fallOffBeam=0	totalDerivs=3836	numOfFeaturizedDerivs=3836
iter=10	group=train	utterance=write a regular expression that only matches strings, no numbers, no special character, just letters from A - Z.	targetValue=(name null)	predValue=(name ?{<num>,<spec>})	predFormula=?{<num>,<spec>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=0	numPartialCorrect=0	numIncorrect=11	numTokens=22	parseTime=22	maxCellSize=11	fallOffBeam=0	totalDerivs=2362	numOfFeaturizedDerivs=2362
iter=10	group=train	utterance=I need to match only strings that include one character leftquoatation / rightquoatation between numbers or integer numbers.	targetValue=(name "sep(?{<num>},</>)")	predValue=(name "sep(?{<num>},</>)")	predFormula="sep(?{<num>},</>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=19	parsed=1	numCandidates=24	parsedNumCandidates=24	numCorrect=1	numPartialCorrect=0	numIncorrect=23	numTokens=19	parseTime=23	maxCellSize=24	fallOffBeam=0	totalDerivs=2574	numOfFeaturizedDerivs=2574
iter=10	group=train	utterance=write regular expression that allows only digits, characters like leftquoatation enumconsts rightquoatation and spaces	targetValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predValue=(name "?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}")	predFormula="?{<num>,or(concat(<e>,concat(<n>,concat(<u>,concat(<m>,concat(<c>,concat(<o>,concat(<n>,concat(<s>,concat(<t>,<s>))))))))),<space>)}"	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=39	parsed=1	numCandidates=124	parsedNumCandidates=124	numCorrect=1	numPartialCorrect=0	numIncorrect=123	numTokens=15	parseTime=22	maxCellSize=124	fallOffBeam=0	totalDerivs=2760	numOfFeaturizedDerivs=2760
iter=10	group=train	utterance=I am trying to implement regex validation for passport number. My requirement is bulletpoint Length should be minimum 3 characters to a maximum of 20 characters. bulletpoint Should not be only leftquoatation 0 rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<num>,3),repeat(<any>,20),<0>}")	predFormula="?{repeat(<num>,3),repeat(<any>,20),<0>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=36	parseTime=966	maxCellSize=2927	fallOffBeam=1	totalDerivs=73994	numOfFeaturizedDerivs=73994
iter=10	group=train	utterance=I want a regular expression that validates a string of length 1 which has either the characters leftquoatation uppera rightquoatation or leftquoatation upperb rightquoatation (case insensitive) at the Begin	targetValue=(name "?{or(<uppera>,<upperb>)}")	predValue=(name "?{or(<uppera>,<upperb>)}")	predFormula="?{or(<uppera>,<upperb>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=19	parsedNumCandidates=19	numCorrect=1	numPartialCorrect=0	numIncorrect=18	numTokens=31	parseTime=84	maxCellSize=19	fallOffBeam=0	totalDerivs=6247	numOfFeaturizedDerivs=6247
iter=10	group=train	utterance=the number with 10 or more digits and that number should not have leftquoatation $ rightquoatation symbol in front of it.	targetValue=(name "?{repeatatleast(<num>,10),<$>}")	predValue=(name "?{repeatatleast(<num>,10),<$>}")	predFormula="?{repeatatleast(<num>,10),<$>}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=15	parsed=1	numCandidates=160	parsedNumCandidates=160	numCorrect=1	numPartialCorrect=0	numIncorrect=159	numTokens=22	parseTime=127	maxCellSize=160	fallOffBeam=0	totalDerivs=11756	numOfFeaturizedDerivs=11756
iter=10	group=train	utterance=I need a regular expression that will test the input bulletpoint Should start with only one leftquoatation + rightquoatation symbol or optional ( + should not come in between ) bulletpoint should not contain alphabets and any other special character bulletpoint Should not contain consecutive leftquoatation + rightquoatation symbols	targetValue=(name null)	predValue=(name "sep(?{<let>,<+>},startwith(<+>))")	predFormula="sep(?{<let>,<+>},startwith(<+>))"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=49	parseTime=4924	maxCellSize=12420	fallOffBeam=1	totalDerivs=383814	numOfFeaturizedDerivs=383814
iter=10	group=train	utterance=I am writing a regular expression to validate a zip code, where it should have exactly a length of 6 characters, the first 3 characters are digits, the last 2 also, but the character 4 should be a space.	targetValue=(name "?{repeat(<let>,6),repeat(<num>,3),repeat(<let>,2),<space>}")	predValue=(name "?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}")	predFormula="?{repeat(<any>,6),repeat(<any>,3),repeat(<any>,2),<space>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=593	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=44	parseTime=3198	maxCellSize=1263	fallOffBeam=1	totalDerivs=184491	numOfFeaturizedDerivs=184491
iter=10	group=train	utterance=I need to validate the next pattern: starts with leftquoatation upperc0 rightquoatation and finish with 4 digits exactly	targetValue=(name "?{concat(<upperc>,<0>),startwith(concat(<upperc>,<0>)),repeat(<num>,4)}")	predValue=(name "?{concat(<upperc>,<0>),endwith(repeat(<num>,4))}")	predFormula="?{concat(<upperc>,<0>),endwith(repeat(<num>,4))}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=80	parsedNumCandidates=80	numCorrect=0	numPartialCorrect=0	numIncorrect=80	numTokens=19	parseTime=31	maxCellSize=80	fallOffBeam=0	totalDerivs=2889	numOfFeaturizedDerivs=2889
iter=10	group=train	utterance=allow only numbers, maxmium two decimals, max one comma (,) and one leftquoatation - rightquoatation symbol in front of the number (optional)	targetValue=(name null)	predValue=(name "sep(?{<num>,<->},<.>)")	predFormula="sep(?{<num>,<->},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=284	maxCellSize=248	fallOffBeam=1	totalDerivs=16829	numOfFeaturizedDerivs=16829
iter=10	group=train	utterance=a regular expression for validating a string with alphanumeric characters and dashes, while also not allowing leading or trailing dashes	targetValue=(name ?{<alphanum>,<->})	predValue=(name ?{<alphanum>,<->})	predFormula=?{<alphanum>,<->}	correct=0.500	oracle=1	partCorrect=0.500	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=41	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=21	parseTime=143	maxCellSize=232	fallOffBeam=1	totalDerivs=10198	numOfFeaturizedDerivs=10198
iter=10	group=train	utterance=I need a regular expression that only validates UK mobile numbers. A UK mobile number can be between 10-14 digits and either starts with leftquoatation 07 rightquoatation, or omits the leftquoatation 0 rightquoatation and starts with leftquoatation 447 rightquoatation. Importantly, if the user adds leftquoatation +44 rightquoatation it should be rejected.	targetValue=(name uppertupperbupperd)	predValue=(name "sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>)))},<num>)")	predFormula="sep(?{startwith(concat(<0>,<7>)),<0>,startwith(concat(<4>,concat(<4>,<7>)))},<num>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=56	parseTime=10857	maxCellSize=4255	fallOffBeam=1	totalDerivs=518792	numOfFeaturizedDerivs=518792
iter=10	group=train	utterance=valid characters are alphanumeric and leftquoatation . rightquoatation(period). The patterns are leftquoatation %d4% rightquoatation and leftquoatation %t7% rightquoatation. So leftquoatation % rightquoatation is not valid by itself, but has to be part of these specific patterns.	targetValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>))))}")	predValue=(name "?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}")	predFormula="?{or(<alphanum>,<.>),or(concat(<%>,concat(<d>,concat(<4>,<%>))),concat(<%>,concat(<t>,concat(<7>,<%>)))),<%>}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=252	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=47	parseTime=2541	maxCellSize=1145	fallOffBeam=1	totalDerivs=110609	numOfFeaturizedDerivs=110609
iter=10	group=train	utterance=accept numeric values that are seven or ten digits	targetValue=(name "?{or(repeat(<num>,7),repeat(<num>,10))}")	predValue=(name "?{<num>,or(repeat(<num>,7),repeat(<num>,10))}")	predFormula="?{<num>,or(repeat(<num>,7),repeat(<num>,10))}"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=1	correctMaxBeamPosition=1	correctMaxUnsortedBeamPosition=8	parsed=1	numCandidates=11	parsedNumCandidates=11	numCorrect=1	numPartialCorrect=0	numIncorrect=10	numTokens=9	parseTime=1	maxCellSize=11	fallOffBeam=0	totalDerivs=324	numOfFeaturizedDerivs=324
iter=10	group=train	utterance=The string must be 9 characters long, starting with leftquoatation uppersuppero- rightquoatation (case insensitive eg leftquoatation upperso- rightquoatation, leftquoatation so- rightquoatation, leftquoatation suppero- rightquoatation and leftquoatation uppersuppero- rightquoatation) followed by 6 numbers.	targetValue=(name "concat(or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->))))),?{repeat(<num>,6)})")	predValue=(name "concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})")	predFormula="concat(?{repeat(<any>,9),concat(<uppers>,concat(<uppero>,<->)),or(concat(<uppers>,concat(<o>,<->)),or(concat(<s>,concat(<o>,<->)),or(concat(<s>,concat(<uppero>,<->)),concat(<uppers>,concat(<uppero>,<->)))))},?{repeat(<num>,6)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=14	correctMaxBeamPosition=14	correctMaxUnsortedBeamPosition=584	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=43	parseTime=4279	maxCellSize=11031	fallOffBeam=1	totalDerivs=357293	numOfFeaturizedDerivs=357293
iter=10	group=train	utterance=I want to write a regular expression using jQuery to validate input fields which will not allow special char at end and the string length should be in between 3 - 25	targetValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predValue=(name "?{endwith(<spec>),repeatrange(<any>,3,25)}")	predFormula="?{endwith(<spec>),repeatrange(<any>,3,25)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=66	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=32	parseTime=304	maxCellSize=335	fallOffBeam=1	totalDerivs=24177	numOfFeaturizedDerivs=24177
iter=10	group=train	utterance=The value should not contain only leftquoatation % rightquoatation and if there is a leftquoatation % rightquoatation the length should be more than 3 characters including leftquoatation % rightquoatation. leftquoatation % rightquoatation can be anywhere in the string (dot is included)	targetValue=(name uppertupperbupperd)	predValue=(name "?{not(contain(<%>)),repeat(<any>,3),<%>}")	predFormula="?{not(contain(<%>)),repeat(<any>,3),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=44	parseTime=1998	maxCellSize=1020	fallOffBeam=1	totalDerivs=112940	numOfFeaturizedDerivs=112940
iter=10	group=train	utterance=The value can have at max 3 decimals (but also none) with comma as the separator.	targetValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=6	parsed=1	numCandidates=13	parsedNumCandidates=13	numCorrect=1	numPartialCorrect=0	numIncorrect=12	numTokens=19	parseTime=17	maxCellSize=13	fallOffBeam=0	totalDerivs=1833	numOfFeaturizedDerivs=1833
iter=10	group=train	utterance=I have a field that should accept: bulletpoint letters [a-zA-Z] bulletpoint letters with numbers [a-zA-Z0-9] bulletpoint no special characters	targetValue=(name "?{<let>,or(<let>,<num>)}")	predValue=(name ?{<let>,<num>})	predFormula=?{<let>,<num>}	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=28	parseTime=81	maxCellSize=237	fallOffBeam=1	totalDerivs=7291	numOfFeaturizedDerivs=7291
iter=10	group=train	utterance=I have one field that is meant to allow a 1 - 3 character string. The first character has got to be leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation, leftquoatation upperc rightquoatation or leftquoatation upperz rightquoatation and may optionally be followed by up to 2 characters.	targetValue=(name "concat(or(<uppera>,or(<upperb>,or(<upperc>,<upperz>))),?{repeatrange(<let>,1,2)})")	predValue=(name "concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})")	predFormula="concat(?{repeat(<any>,3),or(<uppera>,or(<upperb>,or(<upperc>,<upperz>)))},?{repeatrange(<any>,1,2)})"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=13	correctMaxBeamPosition=13	correctMaxUnsortedBeamPosition=864	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=49	parseTime=6497	maxCellSize=9227	fallOffBeam=1	totalDerivs=389910	numOfFeaturizedDerivs=389910
iter=10	group=train	utterance=How can i write valid regular expression for Oracle's Number(2,2), Also digits after decimal should be either, leftquoatation 1 rightquoatation or leftquoatation 2 rightquoatation but not more than leftquoatation 2 rightquoatation, also it can be optional. The number should never start with [1-9] but can start with leftquoatation 0 rightquoatation.	targetValue=(name "sep(?{<num>,<0>},<.>)")	predValue=(name "sep(?{<num>,or(<1>,<2>)},<.>)")	predFormula="sep(?{<num>,or(<1>,<2>)},<.>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=11	correctMaxBeamPosition=11	correctMaxUnsortedBeamPosition=1249	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=61	parseTime=8241	maxCellSize=1752	fallOffBeam=1	totalDerivs=291264	numOfFeaturizedDerivs=291264
iter=10	group=train	utterance=I want regex that only validates that the field contains digits, but that does not care about how many.	targetValue=(name ?{<num>})	predValue=(name ?{<num>})	predFormula=?{<num>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=0	parsed=1	numCandidates=1	parsedNumCandidates=1	numCorrect=1	numPartialCorrect=0	numIncorrect=0	numTokens=21	parseTime=7	maxCellSize=1	fallOffBeam=0	totalDerivs=932	numOfFeaturizedDerivs=932
iter=10	group=train	utterance=Need a regular expression to validate number with comma separator.	targetValue=(name "sep(?{<num>},<,>)")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=2	parsed=1	numCandidates=5	parsedNumCandidates=5	numCorrect=1	numPartialCorrect=0	numIncorrect=4	numTokens=11	parseTime=2	maxCellSize=5	fallOffBeam=0	totalDerivs=392	numOfFeaturizedDerivs=392
iter=10	group=train	utterance=User allowed to enter two characters after leftquoatation % rightquoatation	targetValue=(name null)	predValue=(name "?{repeat(<any>,2),<%>}")	predFormula="?{repeat(<any>,2),<%>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=37	parsedNumCandidates=37	numCorrect=0	numPartialCorrect=0	numIncorrect=37	numTokens=10	parseTime=6	maxCellSize=37	fallOffBeam=0	totalDerivs=798	numOfFeaturizedDerivs=798
iter=10	group=train	utterance=it doesn't start with a space, doesn't contain a space, and doesn't end with a space.	targetValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predValue=(name "?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}")	predFormula="?{not(startwith(<space>)),not(contain(<space>)),not(endwith(<space>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=211	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=22	parseTime=166	maxCellSize=1162	fallOffBeam=1	totalDerivs=18194	numOfFeaturizedDerivs=18194
iter=10	group=train	utterance=Need a regular expression to check a string with 4 digit and the space in trail.	targetValue=(name null)	predValue=(name "?{repeat(<num>,4),<space>}")	predFormula="?{repeat(<num>,4),<space>}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=40	parsedNumCandidates=40	numCorrect=0	numPartialCorrect=0	numIncorrect=40	numTokens=17	parseTime=25	maxCellSize=40	fallOffBeam=0	totalDerivs=2863	numOfFeaturizedDerivs=2863
iter=10	group=train	utterance=We like to validate following with Regex: bulletpoint string may contain 0 or more alphabets, digits, underscore OR bulletpoint string may contain literals leftquoatation %sample1% rightquoatation or leftquoatation %sample2% rightquoatation (0 or more times in any order) 	targetValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predValue=(name "?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}")	predFormula="?{star(or(<let>,or(<num>,<_>))),or(concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<1>,<%>)))))))),concat(<%>,concat(<s>,concat(<a>,concat(<m>,concat(<p>,concat(<l>,concat(<e>,concat(<2>,<%>)))))))))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=698	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=46	parseTime=5207	maxCellSize=1747	fallOffBeam=1	totalDerivs=236337	numOfFeaturizedDerivs=236337
iter=10	group=train	utterance=The input will be in the form a colon (:) separated tuple of three values. The first value will be an integer (potentially a long in terms of size/length), with the other two values being either numeric or a string.	targetValue=(name "sep(?{<num>,repeatatleast(<num>,1),<let>},<:>)")	predValue=(name "?{<:>,repeat(<num>,3)}")	predFormula="?{<:>,repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=31	parsedNumCandidates=31	numCorrect=0	numPartialCorrect=0	numIncorrect=31	numTokens=46	parseTime=101	maxCellSize=31	fallOffBeam=0	totalDerivs=6036	numOfFeaturizedDerivs=6036
iter=10	group=train	utterance=optional number of digits followed by an leftquoatation upperx rightquoatation and an optional (leftquoatation ^ rightquoatation followed by one or more digits)	targetValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predValue=(name "concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})")	predFormula="concat(?{<num>},?{<upperx>,concat(<^>,repeatatleast(<num>,1))})"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1237	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=24	parseTime=235	maxCellSize=1285	fallOffBeam=1	totalDerivs=25295	numOfFeaturizedDerivs=25295
iter=10	group=train	utterance=I'm looking for a regular expression that will match text given the following requirements: contains only 10 digits (only numbers); starts with leftquoatation 9 rightquoatation.	targetValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predValue=(name "?{repeat(<num>,10),startwith(<9>)}")	predFormula="?{repeat(<num>,10),startwith(<9>)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=27	parsed=1	numCandidates=29	parsedNumCandidates=29	numCorrect=1	numPartialCorrect=0	numIncorrect=28	numTokens=31	parseTime=58	maxCellSize=29	fallOffBeam=0	totalDerivs=5177	numOfFeaturizedDerivs=5177
iter=10	group=train	utterance=the first letter of each string is in upper case	targetValue=(name ?{<let>})	predValue=(name ?{<let>})	predFormula=?{<let>}	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=1	parsed=1	numCandidates=3	parsedNumCandidates=3	numCorrect=1	numPartialCorrect=0	numIncorrect=2	numTokens=10	parseTime=2	maxCellSize=3	fallOffBeam=0	totalDerivs=334	numOfFeaturizedDerivs=334
iter=10	group=train	utterance=I'm trying to devise a regular expression which will accept decimal number up to 4 digits.	targetValue=(name "concat(?{<num>},?{<.>,<num>,repeatrange(<num>,1,4)})")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,4)},<.>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,4)},<.>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=8	parsedNumCandidates=8	numCorrect=0	numPartialCorrect=0	numIncorrect=8	numTokens=18	parseTime=10	maxCellSize=8	fallOffBeam=0	totalDerivs=1245	numOfFeaturizedDerivs=1245
iter=10	group=train	utterance=The input box should accept only if either (1) first 2 letters alpha + 6 numeric or (2) 8 numeric	targetValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predValue=(name "?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}")	predFormula="?{repeat(<let>,2),repeat(<num>,6),repeat(<num>,8)}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=64	parsed=1	numCandidates=95	parsedNumCandidates=95	numCorrect=1	numPartialCorrect=0	numIncorrect=94	numTokens=24	parseTime=50	maxCellSize=95	fallOffBeam=0	totalDerivs=4956	numOfFeaturizedDerivs=4956
iter=10	group=train	utterance=I'm trying to validate a form using regular expressions, the conditions are: It has to be a numeric value. It CAN have up to three decimal places(0,1,2 are allowed too).It has to be divided by a comma(,).	targetValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predValue=(name "sep(?{<num>,repeatrange(<num>,1,3)},<,>)")	predFormula="sep(?{<num>,repeatrange(<num>,1,3)},<,>)"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=11	parsed=1	numCandidates=17	parsedNumCandidates=17	numCorrect=1	numPartialCorrect=0	numIncorrect=16	numTokens=50	parseTime=234	maxCellSize=17	fallOffBeam=0	totalDerivs=11176	numOfFeaturizedDerivs=11176
iter=10	group=train	utterance=The name must only consist of letters, numbers and one or more single spaces (not in the beginning or end). The minimum length is 3 characters.	targetValue=(name " ?{<let>,<num>,repeatatleast(<space>,1),<space>,repeatatleast(<let>,3)}")	predValue=(name "?{<let>,repeat(<num>,3)}")	predFormula="?{<let>,repeat(<num>,3)}"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=0	numPartialCorrect=0	numIncorrect=200	numTokens=31	parseTime=201	maxCellSize=508	fallOffBeam=1	totalDerivs=15974	numOfFeaturizedDerivs=15974
iter=10	group=train	utterance=I'm trying to use regular expressions to match a string that does not contain the sequence of characters of a less than symbol leftquoatation < rightquoatation followed by a non space.	targetValue=(name "?{concat(<<>,notcc(<space>))}")	predValue=(name "not(contain(?{<any>,concat(<<>,notcc(<space>))}))")	predFormula="not(contain(?{<any>,concat(<<>,notcc(<space>))}))"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=5	correctMaxBeamPosition=5	correctMaxUnsortedBeamPosition=341	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=33	parseTime=258	maxCellSize=379	fallOffBeam=1	totalDerivs=21173	numOfFeaturizedDerivs=21173
iter=10	group=train	utterance=Can anyone please help me to find the suitable regular expression to validate a string that has comma separated numbers	targetValue=(name "sep(?{<num>},<,>))")	predValue=(name "sep(?{<num>},<,>)")	predFormula="sep(?{<num>},<,>)"	correct=0	oracle=0	partCorrect=0	partOracle=0	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=0	numPartialCorrect=0	numIncorrect=12	numTokens=20	parseTime=8	maxCellSize=12	fallOffBeam=0	totalDerivs=1104	numOfFeaturizedDerivs=1104
iter=10	group=train	utterance=I want to develop one regular expression which validates only strings which have leftquoatation uppera rightquoatation, leftquoatation upperb rightquoatation or leftquoatation upperc rightquoatation	targetValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predValue=(name "?{or(<uppera>,or(<upperb>,<upperc>))}")	predFormula="?{or(<uppera>,or(<upperb>,<upperc>))}"	correct=1	oracle=1	partCorrect=1	partOracle=1	correctIndexAfterParse=0	correctMaxBeamPosition=0	correctMaxUnsortedBeamPosition=3	parsed=1	numCandidates=12	parsedNumCandidates=12	numCorrect=1	numPartialCorrect=0	numIncorrect=11	numTokens=24	parseTime=14	maxCellSize=12	fallOffBeam=0	totalDerivs=1651	numOfFeaturizedDerivs=1651
iter=10	group=train	utterance=I need to validate a string that contains underscore(_) in between the numbers. Underscore character is an optional. Only condition is, it should be between the numbers.	targetValue=(name "sep(?{<num>},<_>)")	predValue=(name "sep(?{<num>,<_>},<_>)")	predFormula="sep(?{<num>,<_>},<_>)"	correct=0	oracle=1	partCorrect=0	partOracle=1	correctIndexAfterParse=7	correctMaxBeamPosition=7	correctMaxUnsortedBeamPosition=144	parsed=1	numCandidates=200	parsedNumCandidates=200	numCorrect=1	numPartialCorrect=0	numIncorrect=199	numTokens=34	parseTime=356	maxCellSize=230	fallOffBeam=1	totalDerivs=22882	numOfFeaturizedDerivs=22882
iter=10	group=train	correct=0.411	oracle=0.629	partCorrect=0.411	partOracle=0.629	correctIndexAfterParse=2.308	correctMaxBeamPosition=2.308	correctMaxUnsortedBeamPosition=404.077	parsed=1	numCandidates=108.323	parsedNumCandidates=108.323	numCorrect=0.629	numPartialCorrect=0	numIncorrect=107.694	numTokens=27.694	parseTime=1711.161	maxCellSize=1623.016	fallOffBeam=0.452	totalDerivs=102554.806	numOfFeaturizedDerivs=102554.806
